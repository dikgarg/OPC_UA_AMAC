/*  Â© Copyright CERN, 2015. All rights not expressly granted are reserved.
    
    The stub of this file was generated by Quasar (additional info: using transform designToDeviceBody.xslt) 
    on 2020-06-24T17:07:22.595-04:00
    
    Quasar is free software: you can redistribute it and/or modify
    it under the terms of the GNU Lesser General Public Licence as published by
    the Free Software Foundation, either version 3 of the Licence.
    Quasar is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Lesser General Public Licence for more details.

    You should have received a copy of the GNU Lesser General Public License
    along with Quasar.  If not, see <http://www.gnu.org/licenses/>.
    1
    
    
*/


#include <Configuration.hxx>

#include <DAMAC.h>
#include <ASAMAC.h>

#include <thread>
#include <cstddef>
#include <iostream>
#include <string.h>
#include <cstring>
#include <bitset>
#include <sstream>
#include <cmath>
#include <fstream>
#include <cstdio>
#include <ctime>

using namespace std;


//================================================================================================================================================
// handy functions to handle data in binary, strings, ints, etc

long int str_to_int(string strVal)   //converting bits to decimal
{
  char *strEnd;
  long int num;
  string strVal1 = "";
  strVal1 = strVal;
  
  num = strtol(strVal1.c_str(), &strEnd, 2); //converts binary to decimal
  
  return num;
}

const char* hexNum_convert(long int num)  //for converting the decimal input to hexadecimal number
{
  int r;  //just a variable
  string hexdec_num = "";
  
  char hex[] = {'0','1','2','3','4','5','6','7','8','9','A','B','C','D','E','F'};
  
  long int dec_num = num;
  
  while(dec_num>0)
    {
      r = dec_num % 16;
      hexdec_num = hex[r] + hexdec_num;
      dec_num = dec_num/16;
    }
  
  return hexdec_num.c_str();
}

int hexaToDecimal (const char num[])
{
  int len = strlen(num);
  int base = 1;
  int temp = 0;
  for (int i=len-1; i>=0; i--) {
    if (num[i]>='0' && num[i]<='9') {
      temp += (num[i] - 48)*base;
      base = base * 16;
    }
    else if (num[i]>='A' && num[i]<='F') {
      temp += (num[i] - 55)*base;
      base = base*16;
    }
  }
  return temp;
}

string bit(int num)  //to set an int value to its 8 bit format(i.e. changing to a byte) and then convert the type to string
{
  return bitset<8> (num).to_string();
}

int bitExtracted(int number, int k, int p)   //for extracting the bits for different fields of a register
{
  return (((1 << k) - 1) & (number >> (p - 1)));
}

const char* intChar_convert(int num) //converting the int format to a char format
{
  std::ostringstream ostr;
  ostr<<num;
  std::string str_temp = ostr.str();
  //cout<<"string num = " << str_temp <<"\n";
  
  return str_temp.c_str();
}


  
  

namespace Device
{
  
  
  // 1111111111111111111111111111111111111111111111111111111111111111111111111
  // 1     GENERATED CODE STARTS HERE AND FINISHES AT SECTION 2              1
  // 1     Users don't modify this code!!!!                                  1
  // 1     If you modify this code you may start a fire or a flood somewhere,1
  // 1     and some human being may possible cease to exist. You don't want  1
  // 1     to be charged with that!                                          1 
  // 1111111111111111111111111111111111111111111111111111111111111111111111111

  
  // 2222222222222222222222222222222222222222222222222222222222222222222222222
  // 2     SEMI CUSTOM CODE STARTS HERE AND FINISHES AT SECTION 3            2
  // 2     (code for which only stubs were generated automatically)          2
  // 2     You should add the implementation but dont alter the headers      2
  // 2     (apart from constructor, in which you should complete initializati2
  // 2     on list)                                                          2 
  // 2222222222222222222222222222222222222222222222222222222222222222222222222
  
  /* sample ctr */
  DAMAC::DAMAC (const Configuration::AMAC & config,
		Parent_DAMAC * parent):Base_DAMAC (config, parent)
				       /* fill up constructor initialization list here */
  {
    /* fill up constructor body here */
  }
  
  /* sample dtr */
  DAMAC::~DAMAC ()
  {
  }
  
  
  // 3333333333333333333333333333333333333333333333333333333333333333333333333
  // 3     FULLY CUSTOM CODE STARTS HERE                                     3
  // 3     Below you put bodies for custom methods defined for this class.   3
  // 3     You can do whatever you want, but please be decent.               3
  // 3333333333333333333333333333333333333333333333333333333333333333333333333
  
  struct AMACReadOnlyMap
  {
    string name;
    int channelNum;
    int regId;
    int offset;
    int bits;
  };
  
  struct std::vector<AMACReadOnlyMap> ReadOnlyRegsMap
  {
    {"Ch0 Value", 0, 10, 0, 10},
    {"Ch1 Value", 1, 10, 10, 10},
    {"Ch2 Value", 2, 10, 20, 10},
    {"Ch3 Value", 3, 11, 0, 10},
    {"Ch4 Value", 4, 11, 10, 10},
    {"Ch5 Value", 5, 11, 20, 10},
    {"Ch6 Value", 6, 12, 0, 10},
    {"Ch7 Value", 7, 12, 10, 10},
    {"Ch8 Value", 8, 12, 20, 10},
    {"Ch9 Value", 9, 13, 0, 10},
    {"Ch10 Value", 10, 13, 10, 10},
    {"Ch11 Value", 11, 13, 20, 10},
    {"Ch12 Value", 12, 14, 0, 10},
    {"Ch13 Value", 13, 14, 10, 10},
    {"Ch14 Value", 14, 14, 20, 10},
    {"Ch15 Value", 15, 15, 0, 10},
    {"Ae", 100, 10, 31, 1},  //Ae values for register 10-15. Their channel numbers are set as 100, 110, 120, 130, 140, 150 corrsponding to their respective registers which are 10,11,12,13,14,15. 
    {"Ae", 110, 11, 31, 1},
    {"Ae", 120, 12, 31, 1},
    {"Ae", 130, 13, 31, 1},
    {"Ae", 140, 14, 31, 1},
    {"Ae", 150, 15, 31, 1},

  };
  
  std::vector<int> BG_settings_stave {  //why do we need to have 28 settings when we only access them through the comm ID which goes from 0 to 13??
    0x8E8D,
    0x8F8E,
    0x8F8E,
    0x8F8F,
    0x8F8F,
    0x8F8E,
    0x8F8E,
    0x8E8E,
    0x8F8D,
    0x8F8E,
    0x8F8E,
    0x8E8D,
    0x8F8D,
    0x8D8F,
    0x8F8F,
    0x8E8E,
    0x8F8D,
    0x8F8E,
    0x8F8F,
    0x8F8D,
    0x8E8D,
    0x8E8E,
    0x8E8D,
    0x8E8D,
    0x8E8C,
    0x8F8F,
    0x8F8D,
    0x8F8D
};

  //vector container for AMAC calibration:
  std::vector<int> AM_offset(16,25);  
  std::vector<float> NTC_vref(3,250);

  std::vector< std::vector<int> > AM_offsets_stave;
  std::vector< std::vector<float> > NTC_vrefs_stave;

  
  void DAMAC::array_declaration()  //gets executed in the server initialization in /server/src/QuasarServer.cpp code
  {
    AM_offsets_stave.clear();
    NTC_vrefs_stave.clear();
    
    int AMACcount=14;
    for (int i=0;i<AMACcount;i++) AM_offsets_stave.push_back(AM_offset); 
    
    for (int i=0;i<AMACcount;i++) NTC_vrefs_stave.push_back(NTC_vref);
  }
  
  // The communication interface backends
  
  // the return values from the communication utilities
  struct amac_return_statusOnly {
    int status;
  };
  
  struct amac_return_statusNlongint {
    int status;
    long int val;
  };
  
  /** \brief The Abstract Class that specifies the class of AMAC interfaces over commandline utilities
   *
   *  This class represents the interface that is embedded into the OPC server right now.
   *  Other interfaces inherit from this one and overwrite the behavior.
   */
  class AMACInterface
  {
  protected:
    //strings defined for the final command line
    // the path to the utility
    // it defines 3 things:
    // 1. the name of the utility -- hence the backend type, the commandline format
    // 2. the path to the utility -- can be many versions of the same one
    // 3. and some static options, like configs, that are custom for each backend
    char paths[300];
    
    // TODO: these two have something to do with addressing? it comes from getParent()->busNumber();
    char channel_temp[2];
    char commID_temp[4];
    
    char command[550];  //the final command line
    
  public:
    //AMACInterface()
    
    void set_paths(string comline_path)
    { strncpy(paths, comline_path.c_str(), sizeof(paths));
      //cout<<"paths = "<<paths<<endl;
    }
    
    void set_channel(const char* chan)
    {
      strncpy(channel_temp, chan, sizeof(channel_temp));
    }
    
    void set_commID(const char* str_commID)
    {
      strncpy(commID_temp, str_commID, sizeof(commID_temp));  //converting the string format of reg_ID to char format
    }
    
    virtual ~AMACInterface() {};
    
    virtual struct amac_return_statusOnly
    setID_fuse(const char* fuse_val) = 0;
    virtual struct amac_return_statusOnly
    setID_bond(const char* str_bond_val)    = 0;
    virtual struct amac_return_statusNlongint
    readReg(char* reg_id)      = 0;
    virtual struct amac_return_statusOnly
    writeReg(char* reg_id, const char* input_value)  = 0;
  };
  
  /** \brief The communication interface utility to AMAC from ITSDAQ, endeavourTest
   *
   * This class collects the utility-related functionality from the OPC server.
   */
  class AMACInterface_ITSDAQCommandline : public AMACInterface
  {
  public:
    struct amac_return_statusOnly setID_fuse(const char* Fuse_val_str)
    {
      snprintf(command, sizeof(command),
	       "%s %s setid_fuse %s 0x%s",
	       paths, channel_temp,
	       commID_temp, Fuse_val_str);
      cout<<"command = "<<command<<endl;  //the final command
      
      FILE *pipe;  // pipe declared to use popen command
      pipe = popen(command,"w");
      pclose(pipe);
      
      return {0};
    }
    
    struct amac_return_statusOnly setID_bond(const char* str_bond_val)
    {
      char bond_val_temp[4];
      strncpy(bond_val_temp, str_bond_val, sizeof(bond_val_temp));  //converting the string format of reg_ID to char format
      
      snprintf(command, sizeof(command),
	       "%s %s setid_bond %s %s",
	       paths, channel_temp,
	       commID_temp, bond_val_temp);
      cout<<"command = "<<command<<endl;  //the final command
      
      FILE *pipe;
      pipe = popen(command,"w");
      pclose(pipe);
      
      return {0};
    }
    
    struct amac_return_statusOnly writeReg(char* reg_id, const char* value)
    {
      snprintf(command, sizeof(command),
	       "%s %s   write %s %s 0x%s",
	       paths, channel_temp,
	       commID_temp, reg_id, value);
      cout<<"command = "<<command<<endl;  //the final command

      FILE *pipe;
      pipe = popen(command,"w");
      pclose(pipe);
      
      return {0};
    }
    
    struct amac_return_statusNlongint readReg(char* regID)
    {
      snprintf(command, sizeof(command),
	       "%s %s   read %s %s",
	       paths, channel_temp,
	       commID_temp, regID);
      cerr<<"command = "<<command<<endl;  //the final command
      cout<<"size of command = "<<strlen(command)<<endl;

      FILE *pipe;
      pipe = popen(command, "r");
      
      char readbuf[100];
      std::vector<char*> field_vect;
      if (pipe == NULL)
	{
	  perror("ERROR, AMACInterface_Powertools::readReg");
	  return {.status=2, .val=0};
	}
      
      else
	{
	  while(!feof(pipe))
	    {
	      if(fgets(readbuf, 100, pipe) == NULL)
		field_vect.push_back(readbuf);
	    }
	}
      
      vector <string> tokens={};
      stringstream ss(field_vect[0]);
      string intermediate;
      
      while(getline(ss, intermediate, ' '))
	{tokens.push_back(intermediate);}
      
      char regvalue[32];
      for (int i=0; i<tokens.size(); i++) {
	if (tokens[i]=="val")
    	  {strncpy(regvalue, (tokens[i+1]).c_str(), sizeof(regvalue));
	    cout<<"value = "<<regvalue<<endl;
	  }
	if (tokens[i]=="255") {
	perror("ERROR, Value read is not a number");
	return {.status=2, .val=0}; 
	  }
      }
      
      stringstream val_str(regvalue);
      long unsigned int val =0.;
      
      val_str>>val;
      
      pclose(pipe);
      
      field_vect.clear();
      tokens.clear();
      return {.status=0, .val=val};
    }
    
    struct amac_return_statusOnly AMACv2_writeConfiguration(int enableDCDC)
    {
      
    }

  };
  
  
  /** \brief A dummy communication interface to AMAC
   *
   * Use for tests
   */
  class AMACInterface_Dummy : public AMACInterface
  {
  private:
    long unsigned int read_val = 111;
    char bond_val[4], fuse_val[10];
    
  public:
    //AMACInterface_Dummy(string comline_path)
    //    { strncpy(paths, (path_str + "-dummy").c_str(), sizeof(paths)); }
    
    struct amac_return_statusOnly setID_fuse(const char* str_val)
    {
      strncpy(fuse_val, str_val, sizeof(fuse_val));
      return {0};
    }
    
    struct amac_return_statusOnly setID_bond(const char* str_val)
    {
      strncpy(bond_val, str_val, sizeof(bond_val));
      return {0};
    }
    
    struct amac_return_statusOnly writeReg(char* reg_id, const char* value)
    {
      return {0};
    }
    
    void set_readReg_val(long int val) { long int read_val = val; }
    
    struct amac_return_statusNlongint readReg(char* str_regID)
    {
      return {.status=0, .val=read_val};
    }
  };
  
  
  /** \brief The communication interface to AMAC with powertools' `endeavour`
   *
   * Launch `endeavour` with a config file as needed to run it on YARR.
   */
  class AMACInterface_Powertools : public AMACInterface
  {
  public:
    //AMACInterface_Dummy(string comline_path)
    //    { strncpy(paths, (path_str + "-dummy").c_str(), sizeof(paths)); }
    
    struct amac_return_statusOnly setID_fuse(const char* str_val)
    {
      cout << "POWERTOOLS BACKEND setID_fuse is not supported yet, returning";
      return {1}; // TODO: cannot find this command in powertools!
      
      //
      // the commandline call
      snprintf(command, sizeof(command),
	       "%s  %s   setid_fuse %s %s",
	       paths, channel_temp,
	       commID_temp, str_val);
      //cout<<"command = " << command << endl;  //the final command
      
      //
      // capture the output
      FILE *pipe;
      pipe = popen(command, "r");
      pclose(pipe);
      
      return {0};
    }
    
    struct amac_return_statusOnly setID_bond(const char* str_val)
    {
      cout << "POWERTOOLS BACKEND setID_bond is not supported yet, returning";
      return {1}; // TODO: cannot find this command in powertools!
      // below is the setid call with refmode set to idpads instead of fuse
      // EndeavourCom::REFMODE refmode=(params[0]=="idpads")?EndeavourCom::REFMODE::IDPads : EndeavourCom::REFMODE::EfuseId;
      
      //
      // the commandline call
      //unsigned int not_clear_what = 0;
      //snprintf(command, sizeof(command),
      //        "%s %s -e %s   setid idpads %X 2> /dev/null",
      //        comline_endeavour_path, comline_options, comline_testbench_config_path,
      //        not_clear_what);
      
      snprintf(command, sizeof(command),
	       "%s %s   setid_bond %s %s",
	       paths, channel_temp,
	       commID_temp, str_val);
      cout<<"command = " << command << endl;  //the final command

      //
      // capture the output
      FILE *pipe;
      pipe = popen(command, "r");
      pclose(pipe);
      
      return {0};
    }
    
    struct amac_return_statusOnly writeReg(char* reg_id, char* value)
    {
      cout << "POWERTOOLS BACKEND writeReg is not supported yet, returning";
      return {1}; // TODO: test separately in powertools first
      
      //
      // the commandline call
      snprintf(command, sizeof(command),
	       "%s   write %.32s %.32s 2> /dev/null",
	       paths,
	       reg_id, value);
      cout<<"command = " << command << endl;  //the final command
      
      //
      // capture the output
      FILE *pipe;
      pipe = popen(command, "r");
      pclose(pipe);
      
      return {0};
    }
    
    struct amac_return_statusNlongint readReg(char* regID)
    {
      //
      // the commandline call
      snprintf(command, sizeof(command),
	       "%s   read %.32s 2> /dev/null", // FIXME: check if powertools understands decimal register IDs
	       paths, regID);
      cout<<"command = "<<command<<endl;  //the final command
      
      //
      // capture the output
      FILE *pipe;
      pipe = popen(command, "r");
      // TODO: test for the exit code!
      
      //
      // parsing
      char read_line_buf[100];
      std::vector<char*> read_field_vect; // a buffer in the parsing of the output of the read
      
      if (pipe == NULL) perror("Empty pipe on read of an AMAC register in ITSDAQ backend");
      else
	{
	  while(!feof(pipe))
	    {
	      if(fgets(read_line_buf, sizeof(read_line_buf), pipe))
		read_field_vect.push_back(read_line_buf);
	    }
	}
      pclose(pipe);
      
      // there must be only 1 line
      // parse the payload from the first line
      unsigned long amac_response_payload = 0; // 32bit
      sscanf(read_field_vect[0], "0x%8lx", &amac_response_payload);
      
      // for control
      cerr << "read_field_vect.size() = " << read_field_vect.size()
	   << " read_field_vect[0] = " << read_field_vect[0]
	   << " and " <<std::hex<< amac_response_payload <<std::dec <<endl;
      
      return {.status=0, .val=amac_response_payload};
    }
  };
  
  
  
  void DAMAC::registers()
  {
    string path_str = (getParent()->path());  //path for communication with the FPGA
    
    AMACInterface* communication_backend;
    // find out which communication interface is set:
    if (path_str.find("endeavourTest") != std::string::npos)
      {
        communication_backend = new AMACInterface_ITSDAQCommandline();
      }
    else if (path_str.find("dummy") != std::string::npos)
      {
        communication_backend = new AMACInterface_Dummy();
      }
    else
      {
        LOG(Log::ERR) << "Unknown backend commindline utility = " << path_str;
        return;
      }
    
    cout<<"paths = "<<path_str<<endl;
    communication_backend->set_paths(path_str);
    
    
    
    // ============== booleans that select AMAC operations to perform
    OpcUa_Boolean setID_bond = getAddressSpaceLink()->getSetID_bond(); //To set bondID
    OpcUa_Boolean setID_fuse = getAddressSpaceLink()->getSetID_Fuse();  //to set FuseID
    OpcUa_Boolean readReg   = getAddressSpaceLink()->getRead();  //to set read register function
    OpcUa_Boolean writeReg  = getAddressSpaceLink()->getWrite();  //to set write register function
    
    OpcUa_Boolean Write_configuration = getAddressSpaceLink()->getWrite_configuration();  //to enable write configuration
    OpcUa_Boolean enDCDC = getAddressSpaceLink()->getEnableDCDC();  //to enable/disable DCDC
    
    OpcUa_Boolean DoOffset  = getAddressSpaceLink()->getDoOffset();  //to enable Offset for HV and NTC

    OpcUa_Boolean getHVCurrent = getAddressSpaceLink()->getHVCurrent();  //to enable to get HV current
    cout<<"HV current boolean = "<<getHVCurrent<<endl;
    
    OpcUa_Boolean EnableNTC  = getAddressSpaceLink()->getEnableNTC();  //to enable to get temeprature from NTC
    cout<<"Temeprature from NTC boolean = "<<EnableNTC<<endl;
    
    // ============== MUX value
    int MUX = getAddressSpaceLink()->getMUX_val();

    // ============== NTC value
    int NTC = getAddressSpaceLink()->getNTC();

    //=============== parameters, converted to necessary format ============================================================================================//
    
    // addressing parameters
    int channel = getParent()->busNumber();
    const char* str_channel_temp = intChar_convert(channel);
    getAddressSpaceLink()->setChannel_num(channel, OpcUa_Good);
    communication_backend->set_channel(str_channel_temp);
    cout<<"channel num is: "<<str_channel_temp<<endl;

    OpcUa_Int32 comm_ID = getAddressSpaceLink()->getComm_ID(); //getting communication ID
    const char* str_commID = intChar_convert(comm_ID);
    communication_backend->set_commID(str_commID);
    
    // values for fuse and bond commands
    int Fuse_val = getAddressSpaceLink()->getFuseID_val();  //to set fuseID value
    char Fuse_val_str[10];
    const char* fuseID_temp = intChar_convert(Fuse_val);
    strcpy(Fuse_val_str, fuseID_temp);
    
    OpcUa_Int64 Bond_val = getAddressSpaceLink()->getBond_value();  //to set bondID value
    const char* str_bond_val = intChar_convert(Bond_val);
    
    
    // ================================= Executing the final commands =================================================== //
    
    
    
    
    // for executing read command line 

    /* The reading of registers section is divided into three parts:
       First part: RO registers 0-31
       Second part: RW registers 40-171
       Third part: RO registers 10-15 ADC value separation defied in a seperate functio called as AMACv2_readAM_calibrated()*/
    
    if (readReg == 1)
      {
        /***************************************************************  Reading the RO registers  *******************************************************************/
        std::vector <long int> readvals={}; //vector to read values of RO registers
        for (unsigned int i=0; i<(ReadOnlyRegs2).size(); i++)
	  {
            int number = ReadOnlyRegs2[i];
            char regID[4];
            strncpy(regID, intChar_convert(number), sizeof(regID));  //converting the reg_ID of int format to a char format
            //cout<<number<<endl;
            //std::ostringstream ostr_regID;
            //ostr_regID<<number;
            //std::string str_regID = ostr_regID.str();  //converting the reg_ID of int format to a string format
            //cout<<"regID = " << regID <<"\n";
	    
            struct amac_return_statusNlongint res = communication_backend->readReg(regID);
	    //cout<<"val = "<<res.val<<endl;
            readvals.push_back(res.val);
	  }
	
	for (int r=0; r<readvals.size(); r++)  //check on the values
	  { //cout<<"RO vals = "<<readvals[r]<<endl; 
	  }
	
        int m=0;
        getAddressSpaceLink()->setReg000 (readvals[m], OpcUa_Good);m++;
        getAddressSpaceLink()->setReg001 (readvals[m], OpcUa_Good);m++;
        getAddressSpaceLink()->setReg002 (readvals[m], OpcUa_Good);m++;
        getAddressSpaceLink()->setReg003 (readvals[m], OpcUa_Good);m++;
        getAddressSpaceLink()->setReg004 (readvals[m], OpcUa_Good);m++;
        getAddressSpaceLink()->setReg005 (readvals[m], OpcUa_Good);m++;
        getAddressSpaceLink()->setReg006 (readvals[m], OpcUa_Good);m++;
        getAddressSpaceLink()->setReg007 (readvals[m], OpcUa_Good);m++;
        getAddressSpaceLink()->setReg010 (readvals[m], OpcUa_Good);m++;
        getAddressSpaceLink()->setReg011 (readvals[m], OpcUa_Good);m++;
        getAddressSpaceLink()->setReg012 (readvals[m], OpcUa_Good);m++;
        getAddressSpaceLink()->setReg013 (readvals[m], OpcUa_Good);m++;
        getAddressSpaceLink()->setReg014 (readvals[m], OpcUa_Good);m++;
        getAddressSpaceLink()->setReg015 (readvals[m], OpcUa_Good);m++;
        getAddressSpaceLink()->setReg024 (readvals[m], OpcUa_Good);m++;
        getAddressSpaceLink()->setReg025 (readvals[m], OpcUa_Good);m++;
        getAddressSpaceLink()->setReg026 (readvals[m], OpcUa_Good);m++;
        getAddressSpaceLink()->setReg027 (readvals[m], OpcUa_Good);m++;
        getAddressSpaceLink()->setReg031 (readvals[m], OpcUa_Good);m=0;

	readvals.clear();

        //Reading the RW registers:
        std::vector <int> readvals1={}; //vector to read values of RW registers
        for (unsigned int i=0; i<(ReadWriteRegs).size(); i++)
	  {
            int number = ReadWriteRegs[i];
            char regID[4];
            strncpy(regID, intChar_convert(number), sizeof(regID));  //converting the reg_ID of int format to a char format
            //cout<<number<<endl;
            //std::ostringstream ostr_regID;
            //ostr_regID<<number;
            //std::string str_regID = ostr_regID.str();  //converting the reg_ID of int format to a string format
            //cout<<"regID = " << regID <<"\n";
	    
            struct amac_return_statusNlongint res = communication_backend->readReg(regID);
            readvals1.push_back(res.val);
	  }
	
        getAddressSpaceLink()->setReg040_Read (readvals1[m], OpcUa_Good);m++;
        getAddressSpaceLink()->setReg041_Read (readvals1[m], OpcUa_Good);m++;
        getAddressSpaceLink()->setReg042_Read (readvals1[m], OpcUa_Good);m++;
        getAddressSpaceLink()->setReg043_Read (readvals1[m], OpcUa_Good);m++;
        getAddressSpaceLink()->setReg044_Read (readvals1[m], OpcUa_Good);m++;
        getAddressSpaceLink()->setReg045_Read (readvals1[m], OpcUa_Good);m++;
        getAddressSpaceLink()->setReg046_Read (readvals1[m], OpcUa_Good);m++;
        getAddressSpaceLink()->setReg047_Read (readvals1[m], OpcUa_Good);m++;
        getAddressSpaceLink()->setReg048_Read (readvals1[m], OpcUa_Good);m++;
        getAddressSpaceLink()->setReg049_Read (readvals1[m], OpcUa_Good);m++;
        getAddressSpaceLink()->setReg050_Read (readvals1[m], OpcUa_Good);m++;
        getAddressSpaceLink()->setReg051_Read (readvals1[m], OpcUa_Good);m++;
        getAddressSpaceLink()->setReg052_Read (readvals1[m], OpcUa_Good);m++;
        getAddressSpaceLink()->setReg053_Read (readvals1[m], OpcUa_Good);m++;  //we need this register specifically for setting the MUX
        getAddressSpaceLink()->setReg054_Read (readvals1[m], OpcUa_Good);m++;
        getAddressSpaceLink()->setReg055_Read (readvals1[m], OpcUa_Good);m++;
        getAddressSpaceLink()->setReg056_Read (readvals1[m], OpcUa_Good);m++;
        getAddressSpaceLink()->setReg057_Read (readvals1[m], OpcUa_Good);m++;
        getAddressSpaceLink()->setReg058_Read (readvals1[m], OpcUa_Good);m++;
        getAddressSpaceLink()->setReg060_Read (readvals1[m], OpcUa_Good);m++;
        getAddressSpaceLink()->setReg061_Read (readvals1[m], OpcUa_Good);m++;
        getAddressSpaceLink()->setReg062_Read (readvals1[m], OpcUa_Good);m++;
        getAddressSpaceLink()->setReg063_Read (readvals1[m], OpcUa_Good);m++;
        getAddressSpaceLink()->setReg064_Read (readvals1[m], OpcUa_Good);m++;
        getAddressSpaceLink()->setReg065_Read (readvals1[m], OpcUa_Good);m++;
        getAddressSpaceLink()->setReg070_Read (readvals1[m], OpcUa_Good);m++;
        getAddressSpaceLink()->setReg071_Read (readvals1[m], OpcUa_Good);m++;
        getAddressSpaceLink()->setReg072_Read (readvals1[m], OpcUa_Good);m++;
        getAddressSpaceLink()->setReg073_Read (readvals1[m], OpcUa_Good);m++;
        getAddressSpaceLink()->setReg074_Read (readvals1[m], OpcUa_Good);m++;
        getAddressSpaceLink()->setReg075_Read (readvals1[m], OpcUa_Good);m++;
        getAddressSpaceLink()->setReg076_Read (readvals1[m], OpcUa_Good);m++;
        getAddressSpaceLink()->setReg077_Read (readvals1[m], OpcUa_Good);m++;
        getAddressSpaceLink()->setReg078_Read (readvals1[m], OpcUa_Good);m++;
        getAddressSpaceLink()->setReg079_Read (readvals1[m], OpcUa_Good);m++;
        getAddressSpaceLink()->setReg080_Read (readvals1[m], OpcUa_Good);m++;
        getAddressSpaceLink()->setReg081_Read (readvals1[m], OpcUa_Good);m++;
        getAddressSpaceLink()->setReg082_Read (readvals1[m], OpcUa_Good);m++;
        getAddressSpaceLink()->setReg083_Read (readvals1[m], OpcUa_Good);m++;
        getAddressSpaceLink()->setReg084_Read (readvals1[m], OpcUa_Good);m++;
        getAddressSpaceLink()->setReg085_Read (readvals1[m], OpcUa_Good);m++;
        getAddressSpaceLink()->setReg086_Read (readvals1[m], OpcUa_Good);m++;
        getAddressSpaceLink()->setReg087_Read (readvals1[m], OpcUa_Good);m++;
        getAddressSpaceLink()->setReg090_Read (readvals1[m], OpcUa_Good);m++;
        getAddressSpaceLink()->setReg091_Read (readvals1[m], OpcUa_Good);m++;
        getAddressSpaceLink()->setReg092_Read (readvals1[m], OpcUa_Good);m++;
        getAddressSpaceLink()->setReg093_Read (readvals1[m], OpcUa_Good);m++;
        getAddressSpaceLink()->setReg094_Read (readvals1[m], OpcUa_Good);m++;
        getAddressSpaceLink()->setReg095_Read (readvals1[m], OpcUa_Good);m++;
        getAddressSpaceLink()->setReg096_Read (readvals1[m], OpcUa_Good);m++;
        getAddressSpaceLink()->setReg100_Read (readvals1[m], OpcUa_Good);m++;
        getAddressSpaceLink()->setReg101_Read (readvals1[m], OpcUa_Good);m++;
        getAddressSpaceLink()->setReg102_Read (readvals1[m], OpcUa_Good);m++;
        getAddressSpaceLink()->setReg103_Read (readvals1[m], OpcUa_Good);m++;
        getAddressSpaceLink()->setReg104_Read (readvals1[m], OpcUa_Good);m++;
        getAddressSpaceLink()->setReg105_Read (readvals1[m], OpcUa_Good);m++;
        getAddressSpaceLink()->setReg106_Read (readvals1[m], OpcUa_Good);m++;
        getAddressSpaceLink()->setReg107_Read (readvals1[m], OpcUa_Good);m++;
        getAddressSpaceLink()->setReg108_Read (readvals1[m], OpcUa_Good);m++;
        getAddressSpaceLink()->setReg109_Read (readvals1[m], OpcUa_Good);m++;
        getAddressSpaceLink()->setReg110_Read (readvals1[m], OpcUa_Good);m++;
        getAddressSpaceLink()->setReg111_Read (readvals1[m], OpcUa_Good);m++;
        getAddressSpaceLink()->setReg112_Read (readvals1[m], OpcUa_Good);m++;
        getAddressSpaceLink()->setReg113_Read (readvals1[m], OpcUa_Good);m++;
        getAddressSpaceLink()->setReg114_Read (readvals1[m], OpcUa_Good);m++;
        getAddressSpaceLink()->setReg115_Read (readvals1[m], OpcUa_Good);m++;
        getAddressSpaceLink()->setReg116_Read (readvals1[m], OpcUa_Good);m++;
        getAddressSpaceLink()->setReg117_Read (readvals1[m], OpcUa_Good);m++;
        getAddressSpaceLink()->setReg118_Read (readvals1[m], OpcUa_Good);m++;
        getAddressSpaceLink()->setReg119_Read (readvals1[m], OpcUa_Good);m++;
        getAddressSpaceLink()->setReg120_Read (readvals1[m], OpcUa_Good);m++;
        getAddressSpaceLink()->setReg121_Read (readvals1[m], OpcUa_Good);m++;
        getAddressSpaceLink()->setReg122_Read (readvals1[m], OpcUa_Good);m++;
        getAddressSpaceLink()->setReg123_Read (readvals1[m], OpcUa_Good);m++;
        getAddressSpaceLink()->setReg124_Read (readvals1[m], OpcUa_Good);m++;
        getAddressSpaceLink()->setReg125_Read (readvals1[m], OpcUa_Good);m++;
        getAddressSpaceLink()->setReg126_Read (readvals1[m], OpcUa_Good);m++;
        getAddressSpaceLink()->setReg127_Read (readvals1[m], OpcUa_Good);m++;
        getAddressSpaceLink()->setReg128_Read (readvals1[m], OpcUa_Good);m++;
        getAddressSpaceLink()->setReg129_Read (readvals1[m], OpcUa_Good);m++;
        getAddressSpaceLink()->setReg130_Read (readvals1[m], OpcUa_Good);m++;
        getAddressSpaceLink()->setReg131_Read (readvals1[m], OpcUa_Good);m++;
        getAddressSpaceLink()->setReg132_Read (readvals1[m], OpcUa_Good);m++;
        getAddressSpaceLink()->setReg133_Read (readvals1[m], OpcUa_Good);m++;
        getAddressSpaceLink()->setReg134_Read (readvals1[m], OpcUa_Good);m++;
        getAddressSpaceLink()->setReg135_Read (readvals1[m], OpcUa_Good);m++;
        getAddressSpaceLink()->setReg136_Read (readvals1[m], OpcUa_Good);m++;
        getAddressSpaceLink()->setReg137_Read (readvals1[m], OpcUa_Good);m++;
        getAddressSpaceLink()->setReg138_Read (readvals1[m], OpcUa_Good);m++;
        getAddressSpaceLink()->setReg139_Read (readvals1[m], OpcUa_Good);m++;
        getAddressSpaceLink()->setReg140_Read (readvals1[m], OpcUa_Good);m++;
        getAddressSpaceLink()->setReg141_Read (readvals1[m], OpcUa_Good);m++;
        getAddressSpaceLink()->setReg142_Read (readvals1[m], OpcUa_Good);m++;
        getAddressSpaceLink()->setReg143_Read (readvals1[m], OpcUa_Good);m++;
        getAddressSpaceLink()->setReg144_Read (readvals1[m], OpcUa_Good);m++;
        getAddressSpaceLink()->setReg145_Read (readvals1[m], OpcUa_Good);m++;
        getAddressSpaceLink()->setReg146_Read (readvals1[m], OpcUa_Good);m++;
        getAddressSpaceLink()->setReg147_Read (readvals1[m], OpcUa_Good);m++;
        getAddressSpaceLink()->setReg148_Read (readvals1[m], OpcUa_Good);m++;
        getAddressSpaceLink()->setReg149_Read (readvals1[m], OpcUa_Good);m++;
        getAddressSpaceLink()->setReg150_Read (readvals1[m], OpcUa_Good);m++;
        getAddressSpaceLink()->setReg151_Read (readvals1[m], OpcUa_Good);m++;
        getAddressSpaceLink()->setReg152_Read (readvals1[m], OpcUa_Good);m++;
        getAddressSpaceLink()->setReg153_Read (readvals1[m], OpcUa_Good);m++;
        getAddressSpaceLink()->setReg154_Read (readvals1[m], OpcUa_Good);m++;
        getAddressSpaceLink()->setReg155_Read (readvals1[m], OpcUa_Good);m++;
        getAddressSpaceLink()->setReg156_Read (readvals1[m], OpcUa_Good);m++;
        getAddressSpaceLink()->setReg157_Read (readvals1[m], OpcUa_Good);m++;
        getAddressSpaceLink()->setReg158_Read (readvals1[m], OpcUa_Good);m++;
        getAddressSpaceLink()->setReg159_Read (readvals1[m], OpcUa_Good);m++;
        getAddressSpaceLink()->setReg160_Read (readvals1[m], OpcUa_Good);m++;
        getAddressSpaceLink()->setReg161_Read (readvals1[m], OpcUa_Good);m++;
        getAddressSpaceLink()->setReg162_Read (readvals1[m], OpcUa_Good);m++;
        getAddressSpaceLink()->setReg163_Read (readvals1[m], OpcUa_Good);m++;
        getAddressSpaceLink()->setReg164_Read (readvals1[m], OpcUa_Good);m++;
        getAddressSpaceLink()->setReg165_Read (readvals1[m], OpcUa_Good);m++;
        getAddressSpaceLink()->setReg166_Read (readvals1[m], OpcUa_Good);m++;
        getAddressSpaceLink()->setReg167_Read (readvals1[m], OpcUa_Good);m++;
        getAddressSpaceLink()->setReg168_Read (readvals1[m], OpcUa_Good);m++;
        getAddressSpaceLink()->setReg169_Read (readvals1[m], OpcUa_Good);m++;
        getAddressSpaceLink()->setReg170_Read (readvals1[m], OpcUa_Good);m++;
        getAddressSpaceLink()->setReg171_Read (readvals1[m], OpcUa_Good);m=0;

	readvals1.clear();

	AMACv2_readAM(0,MUX); //to read the AM block 
	
      }  
    
    //some setting the command clearing isn't here! CHECK IF NEEDED 
    
    //*********************************************  Setting IDs  *************************************//
    if (setID_fuse == 1)
      {
        struct amac_return_statusOnly res = communication_backend->setID_fuse(Fuse_val_str);
        getAddressSpaceLink()->setSetID_Fuse (0, OpcUa_Good);
      }
    
    if (setID_bond == 1)
      {
        struct amac_return_statusOnly res = communication_backend->setID_bond(str_bond_val);
        getAddressSpaceLink()->setSetID_bond (0, OpcUa_Good);
      }
    
    // ******************************************* for executing write command line *************************************************************** //
    vector <int> temp = {};
    if (writeReg == 1)
      {
        temp.push_back(getAddressSpaceLink()->getReg040_Write());
        temp.push_back(getAddressSpaceLink()->getReg041_Write());
        temp.push_back(getAddressSpaceLink()->getReg042_Write());
        temp.push_back(getAddressSpaceLink()->getReg043_Write());
        temp.push_back(getAddressSpaceLink()->getReg044_Write());
        temp.push_back(getAddressSpaceLink()->getReg045_Write());
        temp.push_back(getAddressSpaceLink()->getReg046_Write());
        temp.push_back(getAddressSpaceLink()->getReg047_Write());
        temp.push_back(getAddressSpaceLink()->getReg048_Write());
        temp.push_back(getAddressSpaceLink()->getReg049_Write());
        temp.push_back(getAddressSpaceLink()->getReg050_Write());
        temp.push_back(getAddressSpaceLink()->getReg051_Write());
        temp.push_back(getAddressSpaceLink()->getReg052_Write());
        temp.push_back(getAddressSpaceLink()->getReg053_Write());
        temp.push_back(getAddressSpaceLink()->getReg054_Write());
        temp.push_back(getAddressSpaceLink()->getReg055_Write());
        temp.push_back(getAddressSpaceLink()->getReg056_Write());
        temp.push_back(getAddressSpaceLink()->getReg057_Write());
        temp.push_back(getAddressSpaceLink()->getReg058_Write());
        temp.push_back(getAddressSpaceLink()->getReg060_Write());
        temp.push_back(getAddressSpaceLink()->getReg061_Write());
        temp.push_back(getAddressSpaceLink()->getReg062_Write());
        temp.push_back(getAddressSpaceLink()->getReg063_Write());
        temp.push_back(getAddressSpaceLink()->getReg064_Write());
        temp.push_back(getAddressSpaceLink()->getReg065_Write());
        temp.push_back(getAddressSpaceLink()->getReg070_Write());
        temp.push_back(getAddressSpaceLink()->getReg071_Write());
        temp.push_back(getAddressSpaceLink()->getReg072_Write());
        temp.push_back(getAddressSpaceLink()->getReg073_Write());
        temp.push_back(getAddressSpaceLink()->getReg074_Write());
        temp.push_back(getAddressSpaceLink()->getReg075_Write());
        temp.push_back(getAddressSpaceLink()->getReg076_Write());
        temp.push_back(getAddressSpaceLink()->getReg077_Write());
        temp.push_back(getAddressSpaceLink()->getReg078_Write());
        temp.push_back(getAddressSpaceLink()->getReg079_Write());
        temp.push_back(getAddressSpaceLink()->getReg080_Write());
        temp.push_back(getAddressSpaceLink()->getReg081_Write());
        temp.push_back(getAddressSpaceLink()->getReg082_Write());
        temp.push_back(getAddressSpaceLink()->getReg083_Write());
        temp.push_back(getAddressSpaceLink()->getReg084_Write());
        temp.push_back(getAddressSpaceLink()->getReg085_Write());
        temp.push_back(getAddressSpaceLink()->getReg086_Write());
        temp.push_back(getAddressSpaceLink()->getReg087_Write());
        temp.push_back(getAddressSpaceLink()->getReg090_Write());
        temp.push_back(getAddressSpaceLink()->getReg091_Write());
        temp.push_back(getAddressSpaceLink()->getReg092_Write());
        temp.push_back(getAddressSpaceLink()->getReg093_Write());
        temp.push_back(getAddressSpaceLink()->getReg094_Write());
        temp.push_back(getAddressSpaceLink()->getReg095_Write());
        temp.push_back(getAddressSpaceLink()->getReg096_Write());
        temp.push_back(getAddressSpaceLink()->getReg100_Write());
        temp.push_back(getAddressSpaceLink()->getReg101_Write());
        temp.push_back(getAddressSpaceLink()->getReg102_Write());
        temp.push_back(getAddressSpaceLink()->getReg103_Write());
        temp.push_back(getAddressSpaceLink()->getReg104_Write());
        temp.push_back(getAddressSpaceLink()->getReg105_Write());
        temp.push_back(getAddressSpaceLink()->getReg106_Write());
        temp.push_back(getAddressSpaceLink()->getReg107_Write());
        temp.push_back(getAddressSpaceLink()->getReg108_Write());
        temp.push_back(getAddressSpaceLink()->getReg109_Write());
        temp.push_back(getAddressSpaceLink()->getReg110_Write());
        temp.push_back(getAddressSpaceLink()->getReg111_Write());
        temp.push_back(getAddressSpaceLink()->getReg112_Write());
        temp.push_back(getAddressSpaceLink()->getReg113_Write());
        temp.push_back(getAddressSpaceLink()->getReg114_Write());
        temp.push_back(getAddressSpaceLink()->getReg115_Write());
        temp.push_back(getAddressSpaceLink()->getReg116_Write());
        temp.push_back(getAddressSpaceLink()->getReg117_Write());
        temp.push_back(getAddressSpaceLink()->getReg118_Write());
        temp.push_back(getAddressSpaceLink()->getReg119_Write());
        temp.push_back(getAddressSpaceLink()->getReg120_Write());
        temp.push_back(getAddressSpaceLink()->getReg121_Write());
        temp.push_back(getAddressSpaceLink()->getReg122_Write());
        temp.push_back(getAddressSpaceLink()->getReg123_Write());
        temp.push_back(getAddressSpaceLink()->getReg124_Write());
        temp.push_back(getAddressSpaceLink()->getReg125_Write());
        temp.push_back(getAddressSpaceLink()->getReg126_Write());
        temp.push_back(getAddressSpaceLink()->getReg127_Write());
        temp.push_back(getAddressSpaceLink()->getReg128_Write());
        temp.push_back(getAddressSpaceLink()->getReg129_Write());
        temp.push_back(getAddressSpaceLink()->getReg130_Write());
        temp.push_back(getAddressSpaceLink()->getReg131_Write());
        temp.push_back(getAddressSpaceLink()->getReg132_Write());
        temp.push_back(getAddressSpaceLink()->getReg133_Write());
        temp.push_back(getAddressSpaceLink()->getReg134_Write());
        temp.push_back(getAddressSpaceLink()->getReg135_Write());
        temp.push_back(getAddressSpaceLink()->getReg136_Write());
        temp.push_back(getAddressSpaceLink()->getReg137_Write());
        temp.push_back(getAddressSpaceLink()->getReg138_Write());
        temp.push_back(getAddressSpaceLink()->getReg139_Write());
        temp.push_back(getAddressSpaceLink()->getReg140_Write());
        temp.push_back(getAddressSpaceLink()->getReg141_Write());
        temp.push_back(getAddressSpaceLink()->getReg142_Write());
        temp.push_back(getAddressSpaceLink()->getReg143_Write());
        temp.push_back(getAddressSpaceLink()->getReg144_Write());
        temp.push_back(getAddressSpaceLink()->getReg145_Write());
        temp.push_back(getAddressSpaceLink()->getReg146_Write());
        temp.push_back(getAddressSpaceLink()->getReg147_Write());
        temp.push_back(getAddressSpaceLink()->getReg148_Write());
        temp.push_back(getAddressSpaceLink()->getReg149_Write());
        temp.push_back(getAddressSpaceLink()->getReg150_Write());
        temp.push_back(getAddressSpaceLink()->getReg151_Write());
        temp.push_back(getAddressSpaceLink()->getReg152_Write());
        temp.push_back(getAddressSpaceLink()->getReg153_Write());
        temp.push_back(getAddressSpaceLink()->getReg154_Write());
        temp.push_back(getAddressSpaceLink()->getReg155_Write());
        temp.push_back(getAddressSpaceLink()->getReg156_Write());
        temp.push_back(getAddressSpaceLink()->getReg157_Write());
        temp.push_back(getAddressSpaceLink()->getReg158_Write());
        temp.push_back(getAddressSpaceLink()->getReg159_Write());
        temp.push_back(getAddressSpaceLink()->getReg160_Write());
        temp.push_back(getAddressSpaceLink()->getReg161_Write());
        temp.push_back(getAddressSpaceLink()->getReg162_Write());
        temp.push_back(getAddressSpaceLink()->getReg163_Write());
        temp.push_back(getAddressSpaceLink()->getReg164_Write());
        temp.push_back(getAddressSpaceLink()->getReg165_Write());
        temp.push_back(getAddressSpaceLink()->getReg166_Write());
        temp.push_back(getAddressSpaceLink()->getReg167_Write());
        temp.push_back(getAddressSpaceLink()->getReg168_Write());
        temp.push_back(getAddressSpaceLink()->getReg169_Write());
        temp.push_back(getAddressSpaceLink()->getReg170_Write());
        temp.push_back(getAddressSpaceLink()->getReg171_Write());

        for (unsigned int i=0; i<ReadWriteRegs.size(); i++)
	  {
            char reg_ID_temp[3]; // the target register ID
            char valueReg[8];    // the value to be written to the register
	    
            strncpy(reg_ID_temp, intChar_convert(ReadWriteRegs[i]), sizeof(reg_ID_temp));
            strncpy(valueReg, hexNum_convert(temp[i]), sizeof(valueReg));
	    
            struct amac_return_statusOnly res = communication_backend->writeReg(reg_ID_temp, valueReg);
	  }
	
        getAddressSpaceLink()->setWrite (0, OpcUa_Good);
	temp.clear();
      }

    std::vector<float> NTCvals;
    NTCvals.clear();
    //For setting the offset for HV and NTC
    if (DoOffset==1)  {
      AMACv2_zeroOffset(14);
      AMACv2_zeroOffset(7);
      AMACv2_zeroOffset(8);
      AMACv2_zeroOffset(9);
      
      //int NTCarray[3]={0,1,2};
      //for(int i=0;i<5;i++) {
      //for(int k=0;k<sizeof(NTCarray)/sizeof(NTCarray[0]);k++) {
	  
      AMACv2_NTCref(0);
      AMACv2_NTCref(1);
      AMACv2_NTCref(2);
          
      int Channelcount=16;
      cout<<"AM_offsets: ";
      for (int i=0;i<Channelcount;i++) cout<<AM_offsets_stave.at(comm_ID).at(i)<<endl; 
      int NTCcount=3;
      cout<<"NTC_vref: ";
      for (int i=0;i<NTCcount;i++) cout<<NTC_vrefs_stave.at(comm_ID).at(i)<<endl;
      
      getAddressSpaceLink()->setDoOffset(0, OpcUa_Good);
    }
    
    //For writing the intial configurations for the modules on the stave
    if (Write_configuration==1)  {
      AMACv2_writeConfiguration(int(enDCDC));
      getAddressSpaceLink()->setWrite_configuration(0, OpcUa_Good); }

    // For measuring the HV curent 
    if (getHVCurrent==1) {
      float Ival = AMACv2_readIDET();
      getAddressSpaceLink()->setHVCurrent_value(Ival, OpcUa_Good);
      getAddressSpaceLink()->setHVCurrent(0, OpcUa_Good);
    } 

    
    //For measuring NTC temperature
    if (EnableNTC==1)  {
      
      //****  Take NTC temperature values over time to make a plot of T vs time ****    
      FILE *temp0_ptr;

      char filename0[40];

      snprintf(filename0,sizeof(filename0),"temperature_module_%s_NTC0.dat",str_bond_val);
      
      cout<<"filename : "<<intChar_convert(Bond_val)<<filename0<<endl;
      temp0_ptr = fopen(filename0,"a+");

      chrono::steady_clock sc; 
      auto start = sc.now();   

      //For thermal cycling:
      float temp0=0.;
      temp0 = AMACv2_readNTC(0);

      this_thread::sleep_for(chrono::seconds(5));
      auto end = sc.now();    
      auto time_span = static_cast<chrono::duration<double>>(end - start);  
      cout<<" Operation took: "<<time_span.count()<<" seconds"<< " and temperature for NTC 0 is: "<<temp0<<std::endl; 
	
      fprintf(temp0_ptr,"%lf \t %lf \n",time_span.count(),temp0);
      if (temp0<=10) { 
	cout<<"Reached the desired temperature, stopping now!"<<endl;
	getAddressSpaceLink()->setEnableNTC(0, OpcUa_Good); }

      fclose(temp0_ptr);

      //break; 
    }
	
      //For reading out temperature at one temperature:
      /*float temp0 =0., temp2=0.;
      for (int i=0; i<10; i++) {
	this_thread::sleep_for(chrono::seconds(5) );

	temp0 = AMACv2_readNTC(0);
	//temp2 = AMACv2_readNTC(2);

	auto end = sc.now();    
	auto time_span = static_cast<chrono::duration<double>>(end - start);  
	cout<<"iteration:"<<i<<" Operation took: "<<time_span.count()<<" seconds"<< " and temperature for NTC 0 is: "<<temp0<<std::endl; 
	
	fprintf(temp0_ptr,"%lf \t %lf \n",time_span.count(),temp0);
	//fprintf(temp2_ptr,"%lf \t %lf \n",time_span.count(),temp2);
	
      }
      
      getAddressSpaceLink()->setNTC_value(temp0, OpcUa_Good);
      getAddressSpaceLink()->setEnableNTC(0, OpcUa_Good);
      
      fclose(temp0_ptr);
      //fclose(temp2_ptr);
      }*/

    delete communication_backend;
  }
  

  void AMACv2_writeConfiguration(int enableDCDC)
  {
    string path_str = (getParent()->path());  //path for communication with the FPGA
    
    AMACInterface* communication_backend;
    // find out which communication interface is set:
    if (path_str.find("endeavourTest") != std::string::npos)
      communication_backend = new AMACInterface_ITSDAQCommandline();
    else if (path_str.find("dummy") != std::string::npos)
      communication_backend = new AMACInterface_Dummy();
    else {
      LOG(Log::ERR) << "Unknown backend commindline utility = " << path_str;
      return;
    }
    
    communication_backend->set_paths(path_str);
    
    // addressing parameters
    int channel = getAddressSpaceLink()->getChannel_num();
    communication_backend->set_channel(intChar_convert(channel));

    OpcUa_Int32 comm_ID = getAddressSpaceLink()->getComm_ID(); //getting communication ID
    const char* str_commID = intChar_convert(comm_ID);
    communication_backend->set_commID(str_commID);
    
    int BG_settings=0;
    switch(comm_ID)  {
    case 0:
      BG_settings = BG_settings_stave[0];
      break;
    case 1:
      BG_settings = BG_settings_stave[1];
      break;
    case 2:
      BG_settings = BG_settings_stave[2];
      break;
    case 3:
      BG_settings = BG_settings_stave[3];
      break;
    case 4:
      BG_settings = BG_settings_stave[4];
      break;
    case 5:
      BG_settings = BG_settings_stave[5];
      break;
    case 6:
      BG_settings = BG_settings_stave[6];
      break;
    case 7:
      BG_settings = BG_settings_stave[7];
      break;
    case 8:
      BG_settings = BG_settings_stave[8];
      break;
    case 9:
      BG_settings = BG_settings_stave[9];
      break;
    case 10:
      BG_settings = BG_settings_stave[10];
      break;
    case 11:
      BG_settings = BG_settings_stave[11];
      break;
    case 12:
      BG_settings = BG_settings_stave[12];
      break;
    case 13:
      BG_settings = BG_settings_stave[13];
      break;
    }
    
    cout<<"BG_settings = "<<BG_settings<<endl;

    communication_backend->writeReg("40", hexNum_convert(0x77700)); // HV enabled by default
    communication_backend->writeReg("41", hexNum_convert(0x77700)); // HV enabled by default
    if(enableDCDC == 1){
      communication_backend->writeReg("42", hexNum_convert(0x1)); // DCDC enabled
      communication_backend->writeReg("43", hexNum_convert(0x1)); // DCDC enabled
    }
    else if(enableDCDC == 0){
      communication_backend->writeReg("42", hexNum_convert(0x0)); // DCDC disabled
      communication_backend->writeReg("43", hexNum_convert(0x0)); 
    }
    communication_backend->writeReg("44", hexNum_convert(0x0)); // no interlock or warnings enabled
    communication_backend->writeReg("45", hexNum_convert(0x0)); // no interlock or warnings enabled
    communication_backend->writeReg("46", hexNum_convert(0x10100)); // HCC resets set (takes HCC out of reset)
    communication_backend->writeReg("47", hexNum_convert(0x10100)); // HCC resets set (takes HCC out of reset)
    communication_backend->writeReg("48", hexNum_convert(0x1)); // AM enabled 
    communication_backend->writeReg("49", hexNum_convert(0x1)); // AM enabled 
    communication_backend->writeReg("50", hexNum_convert(0x100)); // require DCDC PGOOD
    communication_backend->writeReg("51", hexNum_convert(0x100)); // require DCDC PGOOD
    communication_backend->writeReg("52", hexNum_convert(BG_settings)); // PB5
    communication_backend->writeReg("53", hexNum_convert(0x0)); // default
    communication_backend->writeReg("54", hexNum_convert(0x0)); // shunt values at zero
    communication_backend->writeReg("55", hexNum_convert(0x19)); // DAC bias at 25 (gives full 1V range on AMAC AM measurement
    communication_backend->writeReg("56", hexNum_convert(0x704)); // default 
    communication_backend->writeReg("57", hexNum_convert(0xc0c0c)); // default
    communication_backend->writeReg("58", hexNum_convert(0x101)); // taking Karol's DCDCoOffset from database
    
    delete communication_backend;
  } 
  
  int DAMAC::AMACv2_readAM(int AMACchan, int MUX)  //For registers 10-16 to read the analog values:
  {
    string path_str = (getParent()->path());  //path for communication with the FPGA
    
    AMACInterface* communication_backend;
    // find out which communication interface is set:
    if (path_str.find("endeavourTest") != std::string::npos)
      communication_backend = new AMACInterface_ITSDAQCommandline();
    else if (path_str.find("dummy") != std::string::npos)
      communication_backend = new AMACInterface_Dummy();
    else {
      LOG(Log::ERR) << "Unknown backend commindline utility = " << path_str;
      return 0;
    }
    
    communication_backend->set_paths(path_str);
    
    // addressing parameters
    //int channel = getParent()->busNumber();
    //const char* str_channel_temp = intChar_convert(channel);
    int channel = getAddressSpaceLink()->getChannel_num();
    communication_backend->set_channel(intChar_convert(channel));
    
    OpcUa_Int32 comm_ID = getAddressSpaceLink()->getComm_ID(); //getting communication ID
    const char* str_commID = intChar_convert(comm_ID);
    communication_backend->set_commID(str_commID);

    //OpcUa_Boolean readReg = read; //getAddressSpaceLink()->getRead();  //to set read register function
    
    vector<pair<int,int>> adc_vals;  //vector for storing the adc values after they are split up
    adc_vals.clear();
    
    //This loop's idea is: First set the MUX correctly using reg53 for Channel-3,4,5,12,13. And record the corresponding field values. For other channels, just seperate the fields of their registers.  	
    for (unsigned int i=0; i<ReadOnlyRegs1.size(); i++) {
      int number = ReadOnlyRegs1[i];
      char regID[3];
      strncpy(regID, intChar_convert(number), sizeof(regID));  //converting the reg_ID of int format to a char format
      //cout<<"regID = "<<regID<<endl;
      
      for (unsigned int j=0; j<ReadOnlyRegsMap.size(); j++){
	if (ReadOnlyRegs1[i] == ReadOnlyRegsMap[j].regId) {
	  int AMchan = ReadOnlyRegsMap[j].channelNum;		
	  if (AMchan==3 || AMchan==4 || AMchan==5 || AMchan==12 || AMchan==13) {
	    int shift = 0;
	    int length = 0;
	     
	    if (AMchan ==3) {
	      shift = 4;
	      length = 2;
	    }
	    if (AMchan == 4) {
	      shift = 8;
	      length = 2;
	    }
	    if (AMchan == 5)
	      {
		shift = 12;
		length = 3;
	      }
	    if (AMchan == 12)
	      {
		shift = 16;
		length = 2;
	      }
	    if (AMchan == 13)
	      {
		shift = 20;
		length = 2;
	      }
	    
	    cout<<"AMChan = "<<AMchan<<endl;
	    struct amac_return_statusNlongint reg = communication_backend->readReg("53");
	    unsigned long int reg53Read = reg.val;
	    cout<<"reg53 = "<<reg53Read<<endl;
	    
	    unsigned long int mask = 0;
	    for (int b = 0; b < length; b++) { mask = (mask << 1) + 1; cout<<"mask="<<mask<<endl; }
	    mask = ~(mask << shift);
	    //cout<<"shift and mask = "<<shift<<"\t"<<mask<<endl;
	    unsigned long int newVal = MUX; //this can take values 1.2.3.4 only.
	    //cout<<"MUX = "<<MUX<<endl; 
	    newVal = newVal << shift;
	    //cout<<"newVal = "<<newVal<<endl;
	    reg53Read = (reg53Read & mask) | newVal;
	    cout<<"reg53 again = "<<reg53Read<<endl;
	    
	    char valueReg[8];
	    strncpy(valueReg, hexNum_convert(reg53Read), sizeof(valueReg));
	    communication_backend->writeReg("53", valueReg);
	    
	    std::this_thread::sleep_for(std::chrono::seconds(1));
	    
	    struct amac_return_statusNlongint res = communication_backend->readReg(regID);
	    long int val = res.val;
	    
	    int field = bitExtracted(val, (ReadOnlyRegsMap[j].bits), ReadOnlyRegsMap[j].offset+1);
	    cout<<"AMchan = "<<AMchan<<"\t val = "<<field<<endl;
	    adc_vals.push_back(std::make_pair(AMchan,field));
	  }
	  
	  else
	    {
	      cout<<"AMChan = "<<AMchan<<endl;	      
	      struct amac_return_statusNlongint res = communication_backend->readReg(regID);
	      long int val = res.val;

	      cout<<"AMChan = "<<AMchan<<" value is: "<<val<<endl;

	      int field = bitExtracted(val, (ReadOnlyRegsMap[j].bits), ReadOnlyRegsMap[j].offset+1);
	      cout<<"AMchan = "<<AMchan<<"\t val = "<<field<<endl;
	      adc_vals.push_back(std::make_pair(AMchan,field));
	    }
	}
      }
    }
    
    for (int r=0; r<adc_vals.size(); r++)  //check on the values
      { //cout<<"AMchan \t val \n"<<adc_vals[r].first<<" \t "<<adc_vals[r].second<<endl; 
      }
    
    
    int m=0;
    getAddressSpaceLink()->setReg010_Ch0(adc_vals[m].second, OpcUa_Good); m++;
    int ch0 = getAddressSpaceLink()->getReg010_Ch0();
    getAddressSpaceLink()->setReg010_Ch1(adc_vals[m].second, OpcUa_Good); m++;
    int ch1 = getAddressSpaceLink()->getReg010_Ch1();
    getAddressSpaceLink()->setReg010_Ch2(adc_vals[m].second, OpcUa_Good); m++;
    int ch2 = getAddressSpaceLink()->getReg010_Ch2();
    getAddressSpaceLink()->setReg010_Ae(adc_vals[m].second, OpcUa_Good); m++;
    
    getAddressSpaceLink()->setReg011_Ch3(adc_vals[m].second, OpcUa_Good); m++;
    int ch3 = getAddressSpaceLink()->getReg011_Ch3();
    getAddressSpaceLink()->setReg011_Ch4(adc_vals[m].second, OpcUa_Good); m++;
    int ch4 = getAddressSpaceLink()->getReg011_Ch4();
    getAddressSpaceLink()->setReg011_Ch5(adc_vals[m].second, OpcUa_Good); m++;
    int ch5 = getAddressSpaceLink()->getReg011_Ch5();
    getAddressSpaceLink()->setReg011_Ae(adc_vals[m].second, OpcUa_Good); m++;
    
    getAddressSpaceLink()->setReg012_Ch6(adc_vals[m].second, OpcUa_Good); m++;
    int ch6 = getAddressSpaceLink()->getReg012_Ch6();
    getAddressSpaceLink()->setReg012_Ch7(adc_vals[m].second, OpcUa_Good); m++;
    int ch7 = getAddressSpaceLink()->getReg012_Ch7();
    getAddressSpaceLink()->setReg012_Ch8(adc_vals[m].second, OpcUa_Good); m++;
    int ch8 = getAddressSpaceLink()->getReg012_Ch8();
    getAddressSpaceLink()->setReg012_Ae(adc_vals[m].second, OpcUa_Good); m++;
    
    getAddressSpaceLink()->setReg013_Ch09(adc_vals[m].second, OpcUa_Good); m++;
    int ch9 = getAddressSpaceLink()->getReg013_Ch09();
    getAddressSpaceLink()->setReg013_Ch10(adc_vals[m].second, OpcUa_Good); m++;
    int ch10 = getAddressSpaceLink()->getReg013_Ch10();
    getAddressSpaceLink()->setReg013_Ch11(adc_vals[m].second, OpcUa_Good); m++;
    int ch11 = getAddressSpaceLink()->getReg013_Ch11();
    getAddressSpaceLink()->setReg013_Ae(adc_vals[m].second, OpcUa_Good); m++;
    
    getAddressSpaceLink()->setReg014_Ch12(adc_vals[m].second, OpcUa_Good); m++;
    int ch12 = getAddressSpaceLink()->getReg014_Ch12();
    getAddressSpaceLink()->setReg014_Ch13(adc_vals[m].second, OpcUa_Good); m++;
    int ch13 = getAddressSpaceLink()->getReg014_Ch13();
    getAddressSpaceLink()->setReg014_Ch14(adc_vals[m].second, OpcUa_Good); m++;
    int ch14 = getAddressSpaceLink()->getReg014_Ch14();
    getAddressSpaceLink()->setReg014_Ae(adc_vals[m].second, OpcUa_Good); m++;
    
    getAddressSpaceLink()->setReg015_Ch15(adc_vals[m].second, OpcUa_Good); m++;
    int ch15 = getAddressSpaceLink()->getReg015_Ch15();
    getAddressSpaceLink()->setReg015_Ae(adc_vals[m].second, OpcUa_Good); m=0;
    
    //int reg40 = getAddressSpaceLink()->getReg040_Read();
    switch(AMACchan) 
      {
      case 0: {cout<<ch0<<endl; return ch0; break;}	
      case 1: {cout<<ch1<<endl; return ch1; break;}
      case 2: {cout<<ch2<<endl; return ch2; break;}
      case 3: {cout<<ch3<<endl; return ch3; break;}
      case 4: {cout<<ch4<<endl; return ch4; break;}
      case 5: {cout<<ch5<<endl; return ch5; break;}
      case 6: {cout<<ch6<<endl; return ch6; break;}
      case 7: {cout<<ch7<<endl; return ch7; break;}
      case 8: {cout<<ch8<<endl; return ch8; break;}
      case 9: {cout<<ch9<<endl; return ch9; break;}
      case 10: {cout<<ch10<<endl; return ch10; break; }
      case 11: {cout<<ch11<<endl; return ch11; break;}
      case 12: {cout<<ch12<<endl; return ch12; break; }
      case 13: {cout<<ch13<<endl; return ch13; break;}
      case 14: {cout<<ch14<<endl; return ch14; break; }
      case 15: {cout<<ch15<<endl; return ch15; break;}
      }
    
    delete communication_backend;
  }


float DAMAC::AMACv2_readIDET() //this is auto-ranging algorithm for current measurement.
  {
    cout<<"============================  IDET starts ================================"<<endl;
     cout<<"\n \n"<<endl;

    string path_str = (getParent()->path());  //path for communication with the FPGA
    
    AMACInterface* communication_backend;
    // find out which communication interface is set:
    if (path_str.find("endeavourTest") != std::string::npos)
      {
        communication_backend = new AMACInterface_ITSDAQCommandline();
      }
    else if (path_str.find("dummy") != std::string::npos)
      {
        communication_backend = new AMACInterface_Dummy();
      }
    else
      {
        LOG(Log::ERR) << "Unknown backend commindline utility = " << path_str;
        return 0;
      }
    
    communication_backend->set_paths(path_str);
    
    // addressing parameters
    //int channel = getParent()->busNumber();
    //const char* str_channel_temp = intChar_convert(channel);
    //getAddressSpaceLink()->setChannel_num(channel, OpcUa_Good);
    int channel = getAddressSpaceLink()->getChannel_num();
    communication_backend->set_channel(intChar_convert(channel));
    
    OpcUa_Int32 comm_ID = getAddressSpaceLink()->getComm_ID(); //getting communication ID
    const char* str_commID = intChar_convert(comm_ID);
    communication_backend->set_commID(str_commID);

    struct amac_return_statusNlongint res = communication_backend->readReg("56");
    long int reg56 = res.val;
    cout<<"initial value of reg 56 = "<<reg56<<endl;
    
    int direction = 0;
    unsigned long int range = (reg56>>16) & 0x0f;
    unsigned long int reading = getAddressSpaceLink()->getReg014_Ch14();
    cout<<"initial range and reading = "<<range<<"\t"<<reading<<endl;
    
    //****  Take 100 ADC count measurements for channel14 to calculate mean and std ****    
     /*FILE *adc_ptr;
     adc_ptr = fopen("datafile.dat","w+");

    int adc=0; 
    for(int i =0; i<100; i++){
      adc = AMACv2_readAM(14, 0);
      fprintf(adc_ptr,"%d \n",adc);
    }
  
    fclose(adc_ptr);*/
  
    //**********************************************************************************
    
    if((reading > 950)&&(range < 8)) {
      // shift left 
      direction = 1;
      if(range==0) range=1;
      else range = (range << 1) & 0x0f;
    }
    if((reading < 200)&&(range > 0)) {
      // shift right
      direction = -1;
      range = (range >> 1) & 0x0f;
    }
    
    cout<<"initial direction and range = "<<direction<<"\t"<<range<<endl;
    while( direction!=0 )  {
      printf("IDET autorange direction %d before adjustment %08lx\n",direction,reg56);
      
      // set the range
      reg56 = ( reg56 & 0xff00ffff) | (range << 16);
      cout<<"**********reg56 = "<<reg56<<endl;
      communication_backend->writeReg("56", hexNum_convert(reg56));
      //std::this_thread::sleep_for(std::chrono::seconds(1));
      
      // read current setting in DAC counts
      reading = AMACv2_readAM(14, 0);
      cout<<"***************reading = "<<reading<<endl;
      //std::this_thread::sleep_for(std::chrono::seconds(1));
      
      if(direction == 1)  {
	if(range==8) direction = 0;
	if(reading > 800){
	  // shift left
	  range = (range << 1) & 0x0f;
	}	   
	else direction = 0;
      }
      
      if(direction == -1)  {
	if(range==0) direction = 0;
	if (reading < 200){
	  // shift right
	  range = (range >> 1) & 0x0f;
	}
	else direction = 0;
      } 
    }

    // get switch configuration
    int S0 = (reg56 >> 16) & 1;
    int S1 = (reg56 >> 17) & 1;
    int S2 = (reg56 >> 18) & 1;
    int S3 = (reg56 >> 19) & 1;
  
    FILE *adc_ptr;
    adc_ptr = fopen("Current_datafile.dat","a+");
    fprintf(adc_ptr,"\n\n Switches for current is: %d \t %d \t %d \t %d \n",S0,S1,S2,S3);

    // resistors
    float R = 200e3;
    float R0 = 19e3;
    float R1 = 1.8e3;
    float R2 = 300;
    float R3 = 120;
  
    // calculate Rset
    float Rset = 1/(1/R+S0/R0+S1/R1+S2/R2+S3/R3);
 
    // returns a number in mV
    std::vector<float> Vids;
    Vids.clear(); 
    //AMACv2_zeroOffset(14);
    for(int i =0; i<5; i++){
      Vids.push_back(AMACv2_readAM_calibrated(comm_ID,14,0));
    }
  
    float Vmean = 0;
    for(int i=0; i<Vids.size(); i++){
      Vmean += Vids.at(i);
    } 
    if(Vids.size()>0){
      Vmean /= (float)Vids.size();
    }
  
    float Vrms = 0;
    for(int i=0; i<Vids.size(); i++){
      Vrms += (Vids.at(i)-Vmean)* (Vids.at(i)-Vmean);
    }
    if(Vids.size()>0){
      float sr = sqrt(Vrms);
      Vrms = sr / (float)Vids.size();
    }
  
    float Imean = Vmean/(1000*Rset);
    float Irms = Vrms/(1000*Rset);

    int register53  = getAddressSpaceLink()->getReg053_Read();
    cout<<"************* I = "<<Imean<<endl;
    fprintf(adc_ptr,"\n HV current return is: %lf \n",Imean);
    fclose(adc_ptr);

    return Imean;

    delete communication_backend;
  }


  float DAMAC::AMACv2_readAM_calibrated(int comm_ID, int AMACchan, int MUX)
  {
    int reading = AMACv2_readAM(AMACchan, MUX);  //for ch 7 and 14, MUX=0
    cout<<"Reading from the channel: "<<AMACchan<<" for the calibration is: "<<reading<<endl;

    float CALfactor = 1.0;
    float m = 0.98;  //temporary slope value
    
    if (AMACchan == 0) CALfactor = 2;
    if (AMACchan == 1) CALfactor = 2;
    if (AMACchan == 2) CALfactor = 15;
    if (AMACchan == 3 && MUX == 0) CALfactor = 1.5;
    
    return CALfactor * (reading - AM_offsets_stave.at(comm_ID).at(AMACchan)) * m;
  }
  
  void DAMAC::AMACv2_zeroOffset(int AMACchan)  
  {
    cout<<"==================  AMAC zero calibration  ====================="<<endl;
    string path_str = (getParent()->path());  //path for communication with the FPGA
    
    AMACInterface* communication_backend;
    // find out which communication interface is set:
    if (path_str.find("endeavourTest") != std::string::npos)
      {
        communication_backend = new AMACInterface_ITSDAQCommandline();
      }
    else if (path_str.find("dummy") != std::string::npos)
      {
        communication_backend = new AMACInterface_Dummy();
      }
    else
      {
        LOG(Log::ERR) << "Unknown backend commindline utility = " << path_str;
        return;
      }
    
    communication_backend->set_paths(path_str);
    
    // addressing parameters
    //int channel = getParent()->busNumber();
    //const char* str_channel_temp = intChar_convert(channel);
    //getAddressSpaceLink()->setChannel_num(channel, OpcUa_Good);
    int channel = getAddressSpaceLink()->getChannel_num();
    communication_backend->set_channel(intChar_convert(channel));
    
    OpcUa_Int32 comm_ID = getAddressSpaceLink()->getComm_ID(); //getting communication ID
    const char* str_commID = intChar_convert(comm_ID);
    communication_backend->set_commID(str_commID);

    // get current state of reg 48 and 49
    long int reg48 = getAddressSpaceLink()->getReg048_Write();
    long int reg49 = getAddressSpaceLink()->getReg049_Write();
    cout<<"** Old reg 48 and reg 49 are : "<<reg48<<" & "<<reg49<<endl;

    // switch zero offset on
    long int reg48_new = reg48 + (1 << 8);
    long int reg49_new = reg49 + (1 << 8);
    cout<<"** New reg 48 and reg 49 are : "<<reg48_new<<" & "<<reg49_new<<endl;

    // write registers
    communication_backend->writeReg("48", hexNum_convert(reg48_new));
    communication_backend->writeReg("49", hexNum_convert(reg49_new));
    std::this_thread::sleep_for(std::chrono::seconds(1));
    
    // read AM
    int reading = AMACv2_readAM(AMACchan,0);  //In zero-offset there is no need for MUX value, because it wil be only done for ch 7 and 14 which dont have any multiplexed values. That's why we have MUX=0 
    AM_offsets_stave.at(comm_ID).at(AMACchan) = reading;
    
    cout<<"*******!!!!!!!!!!!!!!!!!******************** offset value for channel = "<<AMACchan<<"  is: "<<reading<<endl;
    /*FILE *adc_ptr;
    adc_ptr = fopen("Current_datafile.dat","a+");
    fprintf(adc_ptr,"\n\n Offset reading for current is: %f \n",reading);
    fclose(adc_ptr);*/

    // return registers
    communication_backend->writeReg("48", hexNum_convert(reg48));
    communication_backend->writeReg("49", hexNum_convert(reg49));
    std::this_thread::sleep_for(std::chrono::seconds(1));
    
    delete communication_backend;
  }
  
  float DAMAC::AMACv2_readNTC(int NTC) //this is auto-ranging algorithm for NTCs.
  {
    cout<<"============================  NTC starts ================================"<<endl;
    cout<<"\n \n"<<endl;

    string path_str = (getParent()->path());  //path for communication with the FPGA
    
    AMACInterface* communication_backend;
    // find out which communication interface is set:
    if (path_str.find("endeavourTest") != std::string::npos)
      {
        communication_backend = new AMACInterface_ITSDAQCommandline();
      }
    else if (path_str.find("dummy") != std::string::npos)
      {
        communication_backend = new AMACInterface_Dummy();
      }
    else
      {
        LOG(Log::ERR) << "Unknown backend commindline utility = " << path_str;
        return 0.;
      }
    
    communication_backend->set_paths(path_str);
    
    // addressing parameters
    //int channel = getParent()->busNumber();
    //const char* str_channel_temp = intChar_convert(channel);
    int channel = getAddressSpaceLink()->getChannel_num();
    communication_backend->set_channel(intChar_convert(channel));
    
    OpcUa_Int32 comm_ID = getAddressSpaceLink()->getComm_ID(); //getting communication ID
    const char* str_commID = intChar_convert(comm_ID);
    communication_backend->set_commID(str_commID);
    
    struct amac_return_statusNlongint res = communication_backend->readReg("57");
    long int reg57 = res.val;
    cout<<"initial value of reg 57 = "<<reg57<<endl; 
    
    int direction = 0;
    unsigned long int range = (reg57>>(8*NTC)) & 0x07;
    
    //****  Take 100 ADC count measurements for channel 7, 8 or 9 to calculate mean and std ****    
    /*FILE *adc_ptr;
    adc_ptr = fopen("Temperature_datafile.dat","w+");

    int adc=0; 
    for(int i =0; i<100; i++){
      adc = AMACv2_readAM(7+NTC, 0);
      fprintf(adc_ptr,"%d \n",adc);
      }
    
      fclose(adc_ptr);*/
    //**********************************************************************************

    unsigned long int reading=0;
    switch (NTC) {
    case 0:
      reading = getAddressSpaceLink()->getReg012_Ch7();
      break;
    case 1:
      reading = getAddressSpaceLink()->getReg012_Ch8();
      break;
    case 2:
      reading = getAddressSpaceLink()->getReg013_Ch09();
      break;
    }
    cout<<"reading = "<<reading<<" and range = "<<range<<" and NTC = "<<NTC<<" and direction = "<<direction<<endl;
    
    if((reading > 1020)&&(range < 7)){
      direction = 1;
      range++;
    }
    
    if((reading < 100)&&(range > 0)){
      direction = -1;
      range--;
    }

    while( direction!=0 ) {
      printf("NTC %d autorange direction %d before adjustment %08lx\n",NTC,direction,reg57);
      // set the range
      if(NTC==0) reg57 &= 0xfffffff8;  //HybridX, Ch7
      if(NTC==1) reg57 &= 0xfffff8ff;  //HybridY, Ch8
      if(NTC==2) reg57 &= 0xfff8ffff;  //PB, Ch9

      reg57 |= (range << (8*NTC));
      communication_backend->writeReg("57", hexNum_convert(reg57));
      
      printf("NTC %d autorange direction %d after adjustment %08lx\n",NTC,direction,reg57);
      
      // read current setting in DAC counts
      reading = AMACv2_readAM(7+NTC, 0);
      
      cout<<" reading and range are: "<<reading<<" & "<<range<<endl;

      if(direction == 1){
	if(range==7) direction = 0;
	if(reading > 1020) range++;
	else direction = 0;
      }
      
      if(direction == -1){
	if(range==0) direction = 0;
	if (reading < 100) range--;
	else direction = 0;
      } 
    } 
    
    cout<<" reading and range are: "<<reading<<" & "<<range<<endl;

    //AMACv2_zeroOffset(7+NTC);
    float Vntc = AMACv2_readAM_calibrated(comm_ID,7+NTC,0);
    cout<<"Vntc = "<<Vntc<<endl;

    // get switch configuration
    int S0 = ((reg57 >> (8 * NTC)) >> 0) & 1;
    int S1 = ((reg57 >> (8 * NTC)) >> 1) & 1;
    int S2 = ((reg57 >> (8 * NTC)) >> 2) & 1;
    
    //fprintf(adc_ptr,"\n \n ****** switches for NTC temperature are: %d \t %d \t %d \n",S0,S1,S2);

    // resistors
    float R = 200e3;
    float R0 = 133e3;
    float R1 = 50e3;
    float R2 = 22.22e3;
    
    // calculate Rset
    float Rset = 1/(1/R+S0/R0+S1/R1+S2/R2);
    cout<<"Rset= "<<Rset<<endl;

    // calibrate NTC reading here
    //AMACv2_NTCref(NTC);

    //cal function for NTC_ref here to do offset calculations for NTC
    float Acl = Vntc/NTC_vrefs_stave.at(comm_ID).at(NTC);
    float Rntc = Rset/(Acl-1) - 530;
    cout<<"************!!!! Acl = and Rntc = "<<Acl<<"\t"<<Rntc<<endl;
    
    int Channelcount=16;
    cout<<"AM_offsets: ";
    for (int i=0;i<Channelcount;i++) cout<<AM_offsets_stave.at(comm_ID).at(i)<<endl; 
    
    int NTCcount=3;
    cout<<"NTC_vref: ";
    for (int i=0;i<NTCcount;i++) cout<<NTC_vrefs_stave.at(comm_ID).at(i)<<endl;
  
    // remove trace resistance
    if (NTC==0) Rntc -= 80;
    if (NTC==1) Rntc -= 1520;	
    if (NTC==2) Rntc -= 212;
    
    cout<<"Rntc = "<<Rntc<<endl;

    float T = 0;
    if(NTC==2){ // powerboard
      T = 1 / ( log( Rntc / R25_final ) / B_PB_final + 1 / T25_final ) - 273.15;
    }
    else{
      T = 1 / ( log( Rntc / R25_final ) / B_final + 1 / T25_final ) - 273.15;
    }
  
    //fprintf(adc_ptr,"\n \n ****** Temperature is: %lf \n",T);
    //fclose(adc_ptr);

    cout<<"Temperature = "<<T<<endl;
    return T;
  
    delete communication_backend;
  }

  void DAMAC::AMACv2_NTCref(int NTC)
  {
    string path_str = (getParent()->path());  //path for communication with the FPGA
    
    AMACInterface* communication_backend;
    // find out which communication interface is set:
    if (path_str.find("endeavourTest") != std::string::npos)
      {
        communication_backend = new AMACInterface_ITSDAQCommandline();
      }
    else if (path_str.find("dummy") != std::string::npos)
      {
        communication_backend = new AMACInterface_Dummy();
      }
    else
      {
        LOG(Log::ERR) << "Unknown backend commindline utility = " << path_str;
        return;
      }
    
    communication_backend->set_paths(path_str);
    
    // addressing parameters
    //int channel = getParent()->busNumber();
    //const char* str_channel_temp = intChar_convert(channel);
    //getAddressSpaceLink()->setChannel_num(channel, OpcUa_Good);
    //communication_backend->set_channel(str_channel_temp);
    int channel = getAddressSpaceLink()->getChannel_num();
    communication_backend->set_channel(intChar_convert(channel));

    OpcUa_Int32 comm_ID = getAddressSpaceLink()->getComm_ID(); //getting communication ID
    const char* str_commID = intChar_convert(comm_ID);
    communication_backend->set_commID(str_commID);
    
    // get current state of reg 57
    struct amac_return_statusNlongint res = communication_backend->readReg("57");
    long int reg57 = res.val;
    cout<<"initial value of reg 57 = "<<reg57<<endl;

    // switch calibration on
    long int reg57_new = reg57 - (1 << (3 + NTC*8));
    cout<<"new value of reg 57 after calibration is: "<<reg57_new<<endl;

    // write register
    communication_backend->writeReg("57", hexNum_convert(reg57_new));
    std::this_thread::sleep_for(std::chrono::seconds(1));
    
    // read AM
    float reading = AMACv2_readAM_calibrated(comm_ID,7+NTC, 0);
    
    printf("NTC%d Vref\t=%f\n",NTC,reading);
    
    NTC_vrefs_stave.at(comm_ID).at(NTC) = reading;
    
    /*FILE *adc_ptr;
    adc_ptr = fopen("Temperature_datafile.dat","a+");
    fprintf(adc_ptr,"\n\n Offset reading for temperature is: %f \n",reading);
    fclose(adc_ptr);*/

    cout<<"*********************** !!!!!!  NTC vref = "<<reading<<endl;

    // return registers
    communication_backend->writeReg("57", hexNum_convert(reg57));
    std::this_thread::sleep_for(std::chrono::seconds(1));

    delete communication_backend;
  }
  
}




