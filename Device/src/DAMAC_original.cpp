
/*  Â© Copyright CERN, 2015. All rights not expressly granted are reserved.
        
    The stub of this file was generated by Quasar (additional info: using transform designToDeviceBody.xslt) 
    on 2020-06-24T17:07:22.595-04:00
    
    Quasar is free software: you can redistribute it and/or modify
    it under the terms of the GNU Lesser General Public Licence as published by
    the Free Software Foundation, either version 3 of the Licence.
    Quasar is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Lesser General Public Licence for more details.

    You should have received a copy of the GNU Lesser General Public License
    along with Quasar.  If not, see <http://www.gnu.org/licenses/>.
    
    
    
 */


#include <Configuration.hxx>

#include <DAMAC.h>
#include <ASAMAC.h>

#include <thread>
#include <cstddef>
#include <iostream>
#include <string.h>
#include <cstring>
#include <bitset>
#include <sstream>

using namespace std;

//================================================================================================================================================
// handy functions to handle data in binary, strings, ints, etc

long int str_to_int(string strVal)   //converting bits to decimal
{
    char *strEnd;
    long int num;
    string strVal1 = "";
    strVal1 = strVal;

    num = strtol(strVal1.c_str(), &strEnd, 2); //converts binary to decimal

    return num;
}

const char* hexNum_convert(long int num)  //for converting the decimal input to hexadecimal number
{
    int r;  //just a variable
    string hexdec_num = "";

    char hex[] = {'0','1','2','3','4','5','6','7','8','9','A','B','C','D','E','F'};

    long int dec_num = num;

    while(dec_num>0)
    {
        r = dec_num % 16;
        hexdec_num = hex[r] + hexdec_num;
        dec_num = dec_num/16;
    }

    return hexdec_num.c_str();
}

int hexaToDecimal (const char num[])
{
    int len = strlen(num);
    int base = 1;
    int temp = 0;
    for (int i=len-1; i>=0; i--) {
        if (num[i]>='0' && num[i]<='9') {
            temp += (num[i] - 48)*base;
            base = base * 16;
        }
        else if (num[i]>='A' && num[i]<='F') {
            temp += (num[i] - 55)*base;
            base = base*16;
        }
    }
    return temp;
}

string bit(int num)  //to set an int value to its 8 bit format(i.e. changing to a byte) and then convert the type to string
{
    return bitset<8> (num).to_string();
}

int bitExtracted(int number, int k, int p)   //for extracting the bits for different fields of a register
{
    return (((1 << k) - 1) & (number >> (p - 1)));
}

const char* intChar_convert(int num) //converting the int format to a string format
{
    std::ostringstream ostr;
    ostr<<num;
    std::string str_temp = ostr.str();
    //cout<<"string num = " << str_temp <<"\n";

    return str_temp.c_str();
}


namespace Device
{

  
  // 1111111111111111111111111111111111111111111111111111111111111111111111111
  // 1     GENERATED CODE STARTS HERE AND FINISHES AT SECTION 2              1
  // 1     Users don't modify this code!!!!                                  1
  // 1     If you modify this code you may start a fire or a flood somewhere,1
  // 1     and some human being may possible cease to exist. You don't want  1
  // 1     to be charged with that!                                          1 
  // 1111111111111111111111111111111111111111111111111111111111111111111111111


  // 2222222222222222222222222222222222222222222222222222222222222222222222222
  // 2     SEMI CUSTOM CODE STARTS HERE AND FINISHES AT SECTION 3            2
  // 2     (code for which only stubs were generated automatically)          2
  // 2     You should add the implementation but dont alter the headers      2
  // 2     (apart from constructor, in which you should complete initializati2
  // 2     on list)                                                          2 
  // 2222222222222222222222222222222222222222222222222222222222222222222222222

  /* sample ctr */
  DAMAC::DAMAC (const Configuration::AMAC & config,
		Parent_DAMAC * parent):Base_DAMAC (config, parent)
    /* fill up constructor initialization list here */
  {
    /* fill up constructor body here */
  }

  /* sample dtr */
  DAMAC::~DAMAC ()
  {
  }

  
  // 3333333333333333333333333333333333333333333333333333333333333333333333333
  // 3     FULLY CUSTOM CODE STARTS HERE                                     3
  // 3     Below you put bodies for custom methods defined for this class.   3
  // 3     You can do whatever you want, but please be decent.               3
  // 3333333333333333333333333333333333333333333333333333333333333333333333333

  struct AMACReadOnlyMap
  {
    string name;
    int regId;
    int offset;
    int bits;
  };
  
  struct std::vector<AMACReadOnlyMap> ReadOnlyRegsMap
  {
    {"Ch0 Value", 10, 0, 10},
	{"Ch1 Value", 10, 10, 10},
	{"Ch2 Value", 10, 20, 10},
	{"Ch3 Value", 11, 0, 10},
	{"Ch4 Value", 11, 10, 10},
	{"Ch5 Value", 11, 20, 10},
	{"Ch6 Value", 12, 0, 10},
	{"Ch7 Value", 12, 10, 10},
	{"Ch8 Value", 12, 20, 10},
	{"Ch9 Value", 13, 0, 10},
	{"Ch10 Value", 13, 10, 10},
	{"Ch11 Value", 13, 20, 10},
	{"Ch12 Value", 14, 0, 10},
	{"Ch13 Value", 14, 10, 10},
	{"Ch14 Value", 14, 20, 10},
	{"Ch15 Value", 15, 0, 10},
	{"Ae", 10, 31, 1},
	{"Ae", 11, 31, 1},
	{"Ae", 12, 31, 1},
	{"Ae", 13, 31, 1},
	{"Ae", 14, 31, 1},
	{"Ae", 15, 31, 1},

  };
  
  
  void DAMAC::registers()
  {
	  FILE *pipe;  // pipe declared to use popen command

	  //strings defined for the final command line
	  char paths[30];
	  char channel_temp[15];
	  char commID_temp[15];
	  char reg_ID_temp[50];
	  char bond_val_temp[15];
	  const char space[] = " ";
    
	  char command[280];  //the final command line

	  string path_str = (getParent()->path());  //path for communication with the FPGA
	  strcpy(paths, path_str.c_str());
    
	  int Fuse_val = getAddressSpaceLink()->getFuseID_val();  //to get fuseID value
	  OpcUa_Int64 Bond_val = getAddressSpaceLink()->getBond_value();  //to get bondID value

	  //OpcUa_Double channel_num = getAddressSpaceLink()->getChannel_num(); //getting channel number
	  OpcUa_Double comm_ID = getAddressSpaceLink()->getComm_ID(); //getting communication ID
    
	  OpcUa_Boolean setID_bond = getAddressSpaceLink()->getSetID_bond(); //To get bondID
	  OpcUa_Boolean setID_fuse = getAddressSpaceLink()->getSetID_Fuse();  //to get FuseID
    
	  OpcUa_Boolean read_cmd = getAddressSpaceLink()->getRead();  //to set read register function
	  OpcUa_Boolean write_cmd = getAddressSpaceLink()->getWrite();  //to set write register function
    
    
	  //=============== to convert the int format of input variables to string format ======================================================================//
    
	  int channel = getParent()->busNumber();
	  const char* str_channel_temp = intChar_convert(channel);
	  strcpy(channel_temp, str_channel_temp);
	  getAddressSpaceLink()->setChannel_num(channel, OpcUa_Good);  //setting the channel number in the client which can be fixed from the build/bin/config.xml file.
    
	  const char* str_commID = intChar_convert(comm_ID);
	  strcpy(commID_temp, str_commID);  //converting the string format of reg_ID to char format
    
	  char Fuse_val_str[10];
	  const char* fuseID_temp = intChar_convert(Fuse_val);
	  strcpy(Fuse_val_str, fuseID_temp); //converting the string format of fuse_ID to char format
    
	  //const char* str_regID = intChar_convert(reg_id); //converting the string format of reg_ID to char format
    
	  const char* str_bond_val = intChar_convert(Bond_val);
	  strcpy(bond_val_temp, str_bond_val);  //converting the string format of reg_ID to char format
    
	  //==============================================  Register Dictionary  =================================================================================== //
    
    
    //Writing to each register's field
    
    // Method by which you enter the whole register value in one go.
    
    

    /*  switch(reg_id)
	{
    	case 40:
    	case 41:
	{const char* temp;
	temp = hexNum_convert(reg40_write);
	strcpy(valueReg, temp);}
	}*/

    
    // A method in which you enter register number and press set field to start seeing each field name for that register and then you can go one by one filling all of it.
    
    /*    std::vector <temp_AMACRegInfo> field_write_dets; //a temporary vector to store the AMAC regsiter's information
	  
	  
	  if (Set_field_cmd == 1)
	  {
	  for (int i=0; i<regInfo.size(); i++)
	  {
	  if (reg_id == regInfo[i].regId)
	  field_write_dets.push_back({regInfo[i].name, regInfo[i].offset, regInfo[i].bits });
	  }
	  
	  for (int j=0; j<field_write_dets.size(); j++)
	  {
	  cout<<field_write_dets[j].name<<"\t";
	  
	  }
	  
	  cout<<"\n";
	  
	  while(k != (field_write_dets.size()))
	  {
	  std::ostringstream ostr_bits;
	  ostr_bits<<field_write_dets[k].bits;
	  string name_temp = (field_write_dets[k].name) + "(" + (ostr_bits).str() + ")";
	  getAddressSpaceLink()-> setField_name (name_temp.c_str(), OpcUa_Good);
	  if (next_cmd == 1)
	  {
	  int field_num = (field_val)<<field_write_dets[k].offset; //bit shifting
	  
	  //cout<<"f= "<<field_num<<endl;
	  
	  field_vect.push_back(field_num);
	  
	  int size = field_vect.size();
	  
	  //cout<<"size = "<<size<<endl;
	  //for (int j=0; j<size; j++) {cout<<field_vect[j]<<"\t";}
	  //cout<<"\n";
	  //cout<<"last = "<<field_vect[size-1.]<<endl;
	  //cout<<"last b4 = "<<field_vect[(size-2.)]<<endl;
	  
	  int field_int = field_vect[size-1.] | field_vect[(size-2.)];
	  cout<<bitset <32>(field_int)<<endl;
	  field_vect.push_back(field_int);
	  //for (int j=0; j<size; j++) {cout<<field_vect[j]<<"\t";}
			
	  k+=1;
	  
	  next_cmd=0;
	  getAddressSpaceLink()->setNext (0, OpcUa_Good);
	  }
	  
	  else
	  break;
	  }
	  
	  if (k == (field_write_dets.size()))
	  {getAddressSpaceLink()->setSet_Field (0, OpcUa_Good);
	  getAddressSpaceLink()->setNext (0, OpcUa_Good);
	  string name = "Done with all the bits of this register! :) ";
	  getAddressSpaceLink()-> setField_name (name.c_str(), OpcUa_Good);}
	  
	  }
	  
	  cout<<"\n"; */
    
    //A method in which you enter the field name and field value and then set field to set the value, then you move ahead to the next field and do this till you are done with writing to each field and then you finally can give the write command.
    /*    if (Set_field_cmd == 1)
	  {
	  for (int i=0; i<regInfo.size(); i++)
	  {
	  
	  if (reg_id == regInfo[i].regId && field_name_str == regInfo[i].name)
	  {
	  
	  if ((field_val_str).length() != regInfo[i].bits) {cout<<"The length of the input bits for " << field_name_str << "field is not correct. Please enter "<<regInfo[i].bits<<" bits."<<endl; }
	  
	  else
	  {
	  int field_num = str_to_int(field_val_str)<<regInfo[i].offset; //bit shifting
	  
	  cout<<"f= "<<field_num<<endl;
	  
	  field_vect.push_back(field_num);
	  
	  int size = field_vect.size();
	  
	  cout<<"size = "<<size<<endl;
	  for (int j=0; j<size; j++) {cout<<field_vect[j]<<"\t";}
	  cout<<"\n";
	  cout<<"last = "<<field_vect[size-1.]<<endl;
	  cout<<"last b4 = "<<field_vect[(size-2.)]<<endl;
	  
	  int field_int = field_vect[size-1.] | field_vect[(size-2.)];
	  cout<<bitset <32>(field_int)<<endl;
	  field_vect.push_back(field_int);
	  for (int j=0; j<size; j++) {cout<<"HI"<<field_vect[j]<<"\t";}
	  }
	  
	  }
	  getAddressSpaceLink()->setSet_Field (0, OpcUa_Good);
	  }
	  
	  }*/
    
    
    
	  // ================================= Executing the final commands =================================================== //
    
	  strcpy (command,paths);
	  strcat (command, space);
	  strcat (command,channel_temp);
    
    
	  // ************************************* for executing read command line **************************************************************************** //

	  cout<<"command = "<<command<<endl;

	  string field_name_str;
	  if (read_cmd == 1)
	  {
		  const char function[] = "read";
		  char readbuf[100];
	
		  std::vector<char*> field_vect; //used for storing the last line of the command line when read command is executed
		  strcat(command, space);
		  strcat (command,function);
		  strcat(command, space);
		  strcat (command, commID_temp);
		  strcat(command, space);
	
		  //=========================================  Reading the RO registers  =============================================================================//

		  std::vector <int> readvals={}; //vector to store read values of RO registers
		  for (int i=0; i<static_cast<int>(ReadOnlyRegs2.size()); i++)
		  {
			  int number = ReadOnlyRegs2[i];
			  cout<<number<<endl;
			  std::ostringstream ostr_regID;
			  ostr_regID<<number;
			  std::string str_regID = ostr_regID.str();  //converting the reg_ID of int format to a string format
			  cout<<"s = " << str_regID <<"\n";
			  strcpy(reg_ID_temp, str_regID.c_str());
			  cout<<"reg_ID_temp = "<<reg_ID_temp<<endl;

			  strcat (command, reg_ID_temp);
	    
			  cout<<"command = "<<command<<endl;  //the final command

			  pipe = popen(command,"r");
	    
			  if (pipe == NULL) perror("ERROR");
			  else
			  {
				  while(!feof(pipe))
				  {
					  if(fgets(readbuf, 100, pipe) == NULL)
						  field_vect.push_back(readbuf);
				  }
			  }

			  vector <string> tokens={};
			  stringstream ss(field_vect[0]);
			  string intermediate;
		
			  cout<<field_vect[0]<<endl;
			  while(getline(ss, intermediate, ' '))
				  tokens.push_back(intermediate);

			  string vals_tk;
			  for (int t=0; t<static_cast<int>(tokens.size()); t++)  //extracting the value obtained from reading the register and storing it in a vector so that the value can be updated in client
			  {
				  if (tokens[t] == "val")
				  {
					  vals_tk=tokens[t+1];
					  cout<<tokens[t+1]<<endl;
				  }
			  }

			  stringstream val_str(vals_tk);
			  long int val =0.;

			  val_str>>val;

			  readvals.push_back(val);
	    
			  command[strlen(command)-(strlen(reg_ID_temp))] = '\0';
			  pclose(pipe);

			  field_vect.clear();
			  tokens.clear();
	    
		  }
	
		  int m=0;
		  getAddressSpaceLink()->setReg000 (readvals[m], OpcUa_Good);m++;
		  getAddressSpaceLink()->setReg001 (readvals[m], OpcUa_Good);m++;
		  getAddressSpaceLink()->setReg002 (readvals[m], OpcUa_Good);m++;
		  getAddressSpaceLink()->setReg003 (readvals[m], OpcUa_Good);m++;
		  getAddressSpaceLink()->setReg004 (readvals[m], OpcUa_Good);m++;
		  getAddressSpaceLink()->setReg005 (readvals[m], OpcUa_Good);m++;
		  getAddressSpaceLink()->setReg006 (readvals[m], OpcUa_Good);m++;
		  getAddressSpaceLink()->setReg007 (readvals[m], OpcUa_Good);m++;
		  getAddressSpaceLink()->setReg010 (readvals[m], OpcUa_Good);m++;
		  getAddressSpaceLink()->setReg011 (readvals[m], OpcUa_Good);m++;
		  getAddressSpaceLink()->setReg012 (readvals[m], OpcUa_Good);m++;
		  getAddressSpaceLink()->setReg013 (readvals[m], OpcUa_Good);m++;
		  getAddressSpaceLink()->setReg014 (readvals[m], OpcUa_Good);m++;
		  getAddressSpaceLink()->setReg015 (readvals[m], OpcUa_Good);m++;
		  getAddressSpaceLink()->setReg024 (readvals[m], OpcUa_Good);m++;
		  getAddressSpaceLink()->setReg025 (readvals[m], OpcUa_Good);m++;
		  getAddressSpaceLink()->setReg026 (readvals[m], OpcUa_Good);m++;
		  getAddressSpaceLink()->setReg027 (readvals[m], OpcUa_Good);m++;
		  getAddressSpaceLink()->setReg031 (readvals[m], OpcUa_Good);m=0;

		  readvals.clear();

		  //================================================  Reading the RW registers =========================================================================//

		  std::vector <int> readvals1={}; //vector to read values of RW registers
		  for (int i=0; i<static_cast<int>(ReadWriteRegs.size()); i++)
		  {
			  int number = ReadWriteRegs[i];
			  cout<<number<<endl;
			  std::ostringstream ostr_regID;
			  ostr_regID<<number;
			  std::string str_regID = ostr_regID.str();  //converting the reg_ID of int format to a string format
			  cout<<"s = " << str_regID <<"\n";
			  strcpy(reg_ID_temp, str_regID.c_str());
			  cout<<"reg_ID_temp = "<<reg_ID_temp<<endl;
			  //strcat(command, space);
			  strcat (command, reg_ID_temp);

			  cout<<"command = "<<command<<endl;  //the final command

			  pipe = popen(command,"r");
	    
			  if (pipe == NULL) perror("ERROR");
			  else
			  {
				  while(!feof(pipe))
				  {
					  if(fgets(readbuf, 100, pipe) == NULL)
						  field_vect.push_back(readbuf);
				  }
			  }
	    
			  vector <string> tokens;
	    
			  stringstream ss(field_vect[0]);

			  string intermediate;

			  while(getline(ss, intermediate, ' '))
				  tokens.push_back(intermediate);

			  string vals_tk;
			  for (int t=0; t<static_cast<int>(tokens.size()); t++)
			  {
				  if (tokens[t] == "val")
				  {
					  vals_tk=tokens[t+1];
					  cout<<tokens[t+1]<<endl;
				  }
			  }

			  stringstream val_str(vals_tk);
			  long int val =0.;

			  val_str>>val;

			  readvals1.push_back(val);

			  command[strlen(command)-(strlen(reg_ID_temp))] = '\0';
			  pclose(pipe);

			  field_vect.clear();
			  tokens.clear();

		  }
	
		  getAddressSpaceLink()->setReg040_Read (readvals1[m], OpcUa_Good);m++;
		  getAddressSpaceLink()->setReg041_Read (readvals1[m], OpcUa_Good);m++;
		  getAddressSpaceLink()->setReg042_Read (readvals1[m], OpcUa_Good);m++;
		  getAddressSpaceLink()->setReg043_Read (readvals1[m], OpcUa_Good);m++;
		  getAddressSpaceLink()->setReg044_Read (readvals1[m], OpcUa_Good);m++;
		  getAddressSpaceLink()->setReg045_Read (readvals1[m], OpcUa_Good);m++;
		  getAddressSpaceLink()->setReg046_Read (readvals1[m], OpcUa_Good);m++;
		  getAddressSpaceLink()->setReg047_Read (readvals1[m], OpcUa_Good);m++;
		  getAddressSpaceLink()->setReg048_Read (readvals1[m], OpcUa_Good);m++;
		  getAddressSpaceLink()->setReg049_Read (readvals1[m], OpcUa_Good);m++;
		  getAddressSpaceLink()->setReg050_Read (readvals1[m], OpcUa_Good);m++;
		  getAddressSpaceLink()->setReg051_Read (readvals1[m], OpcUa_Good);m++;
		  getAddressSpaceLink()->setReg052_Read (readvals1[m], OpcUa_Good);m++;
		  getAddressSpaceLink()->setReg053_Read (readvals1[m], OpcUa_Good);m++;
		  getAddressSpaceLink()->setReg054_Read (readvals1[m], OpcUa_Good);m++;
		  getAddressSpaceLink()->setReg055_Read (readvals1[m], OpcUa_Good);m++;
		  getAddressSpaceLink()->setReg056_Read (readvals1[m], OpcUa_Good);m++;
		  getAddressSpaceLink()->setReg057_Read (readvals1[m], OpcUa_Good);m++;
		  getAddressSpaceLink()->setReg058_Read (readvals1[m], OpcUa_Good);m++;
		  getAddressSpaceLink()->setReg060_Read (readvals1[m], OpcUa_Good);m++;
		  getAddressSpaceLink()->setReg061_Read (readvals1[m], OpcUa_Good);m++;
		  getAddressSpaceLink()->setReg062_Read (readvals1[m], OpcUa_Good);m++;
		  getAddressSpaceLink()->setReg063_Read (readvals1[m], OpcUa_Good);m++;
		  getAddressSpaceLink()->setReg064_Read (readvals1[m], OpcUa_Good);m++;
		  getAddressSpaceLink()->setReg065_Read (readvals1[m], OpcUa_Good);m++;
		  getAddressSpaceLink()->setReg070_Read (readvals1[m], OpcUa_Good);m++;
		  getAddressSpaceLink()->setReg071_Read (readvals1[m], OpcUa_Good);m++;
		  getAddressSpaceLink()->setReg072_Read (readvals1[m], OpcUa_Good);m++;
		  getAddressSpaceLink()->setReg073_Read (readvals1[m], OpcUa_Good);m++;
		  getAddressSpaceLink()->setReg074_Read (readvals1[m], OpcUa_Good);m++;
		  getAddressSpaceLink()->setReg075_Read (readvals1[m], OpcUa_Good);m++;
		  getAddressSpaceLink()->setReg076_Read (readvals1[m], OpcUa_Good);m++;
		  getAddressSpaceLink()->setReg077_Read (readvals1[m], OpcUa_Good);m++;
		  getAddressSpaceLink()->setReg078_Read (readvals1[m], OpcUa_Good);m++;
		  getAddressSpaceLink()->setReg079_Read (readvals1[m], OpcUa_Good);m++;
		  getAddressSpaceLink()->setReg080_Read (readvals1[m], OpcUa_Good);m++;
		  getAddressSpaceLink()->setReg081_Read (readvals1[m], OpcUa_Good);m++;
		  getAddressSpaceLink()->setReg082_Read (readvals1[m], OpcUa_Good);m++;
		  getAddressSpaceLink()->setReg083_Read (readvals1[m], OpcUa_Good);m++;
		  getAddressSpaceLink()->setReg084_Read (readvals1[m], OpcUa_Good);m++;
		  getAddressSpaceLink()->setReg085_Read (readvals1[m], OpcUa_Good);m++;
		  getAddressSpaceLink()->setReg086_Read (readvals1[m], OpcUa_Good);m++;
		  getAddressSpaceLink()->setReg087_Read (readvals1[m], OpcUa_Good);m++;
		  getAddressSpaceLink()->setReg090_Read (readvals1[m], OpcUa_Good);m++;
		  getAddressSpaceLink()->setReg091_Read (readvals1[m], OpcUa_Good);m++;
		  getAddressSpaceLink()->setReg092_Read (readvals1[m], OpcUa_Good);m++;
		  getAddressSpaceLink()->setReg093_Read (readvals1[m], OpcUa_Good);m++;
		  getAddressSpaceLink()->setReg094_Read (readvals1[m], OpcUa_Good);m++;
		  getAddressSpaceLink()->setReg095_Read (readvals1[m], OpcUa_Good);m++;
		  getAddressSpaceLink()->setReg096_Read (readvals1[m], OpcUa_Good);m++;
		  getAddressSpaceLink()->setReg100_Read (readvals1[m], OpcUa_Good);m++;
		  getAddressSpaceLink()->setReg101_Read (readvals1[m], OpcUa_Good);m++;
		  getAddressSpaceLink()->setReg102_Read (readvals1[m], OpcUa_Good);m++;
		  getAddressSpaceLink()->setReg103_Read (readvals1[m], OpcUa_Good);m++;
		  getAddressSpaceLink()->setReg104_Read (readvals1[m], OpcUa_Good);m++;
		  getAddressSpaceLink()->setReg105_Read (readvals1[m], OpcUa_Good);m++;
		  getAddressSpaceLink()->setReg106_Read (readvals1[m], OpcUa_Good);m++;
		  getAddressSpaceLink()->setReg107_Read (readvals1[m], OpcUa_Good);m++;
		  getAddressSpaceLink()->setReg108_Read (readvals1[m], OpcUa_Good);m++;
		  getAddressSpaceLink()->setReg109_Read (readvals1[m], OpcUa_Good);m++;
		  getAddressSpaceLink()->setReg110_Read (readvals1[m], OpcUa_Good);m++;
		  getAddressSpaceLink()->setReg111_Read (readvals1[m], OpcUa_Good);m++;
		  getAddressSpaceLink()->setReg112_Read (readvals1[m], OpcUa_Good);m++;
		  getAddressSpaceLink()->setReg113_Read (readvals1[m], OpcUa_Good);m++;
		  getAddressSpaceLink()->setReg114_Read (readvals1[m], OpcUa_Good);m++;
		  getAddressSpaceLink()->setReg115_Read (readvals1[m], OpcUa_Good);m++;
		  getAddressSpaceLink()->setReg116_Read (readvals1[m], OpcUa_Good);m++;
		  getAddressSpaceLink()->setReg117_Read (readvals1[m], OpcUa_Good);m++;
		  getAddressSpaceLink()->setReg118_Read (readvals1[m], OpcUa_Good);m++;
		  getAddressSpaceLink()->setReg119_Read (readvals1[m], OpcUa_Good);m++;
		  getAddressSpaceLink()->setReg120_Read (readvals1[m], OpcUa_Good);m++;
		  getAddressSpaceLink()->setReg121_Read (readvals1[m], OpcUa_Good);m++;
		  getAddressSpaceLink()->setReg122_Read (readvals1[m], OpcUa_Good);m++;
		  getAddressSpaceLink()->setReg123_Read (readvals1[m], OpcUa_Good);m++;
		  getAddressSpaceLink()->setReg124_Read (readvals1[m], OpcUa_Good);m++;
		  getAddressSpaceLink()->setReg125_Read (readvals1[m], OpcUa_Good);m++;
		  getAddressSpaceLink()->setReg126_Read (readvals1[m], OpcUa_Good);m++;
		  getAddressSpaceLink()->setReg127_Read (readvals1[m], OpcUa_Good);m++;
		  getAddressSpaceLink()->setReg128_Read (readvals1[m], OpcUa_Good);m++;
		  getAddressSpaceLink()->setReg129_Read (readvals1[m], OpcUa_Good);m++;
		  getAddressSpaceLink()->setReg130_Read (readvals1[m], OpcUa_Good);m++;
		  getAddressSpaceLink()->setReg131_Read (readvals1[m], OpcUa_Good);m++;
		  getAddressSpaceLink()->setReg132_Read (readvals1[m], OpcUa_Good);m++;
		  getAddressSpaceLink()->setReg133_Read (readvals1[m], OpcUa_Good);m++;
		  getAddressSpaceLink()->setReg134_Read (readvals1[m], OpcUa_Good);m++;
		  getAddressSpaceLink()->setReg135_Read (readvals1[m], OpcUa_Good);m++;
		  getAddressSpaceLink()->setReg136_Read (readvals1[m], OpcUa_Good);m++;
		  getAddressSpaceLink()->setReg137_Read (readvals1[m], OpcUa_Good);m++;
		  getAddressSpaceLink()->setReg138_Read (readvals1[m], OpcUa_Good);m++;
		  getAddressSpaceLink()->setReg139_Read (readvals1[m], OpcUa_Good);m++;
		  getAddressSpaceLink()->setReg140_Read (readvals1[m], OpcUa_Good);m++;
		  getAddressSpaceLink()->setReg141_Read (readvals1[m], OpcUa_Good);m++;
		  getAddressSpaceLink()->setReg142_Read (readvals1[m], OpcUa_Good);m++;
		  getAddressSpaceLink()->setReg143_Read (readvals1[m], OpcUa_Good);m++;
		  getAddressSpaceLink()->setReg144_Read (readvals1[m], OpcUa_Good);m++;
		  getAddressSpaceLink()->setReg145_Read (readvals1[m], OpcUa_Good);m++;
		  getAddressSpaceLink()->setReg146_Read (readvals1[m], OpcUa_Good);m++;
		  getAddressSpaceLink()->setReg147_Read (readvals1[m], OpcUa_Good);m++;
		  getAddressSpaceLink()->setReg148_Read (readvals1[m], OpcUa_Good);m++;
		  getAddressSpaceLink()->setReg149_Read (readvals1[m], OpcUa_Good);m++;
		  getAddressSpaceLink()->setReg150_Read (readvals1[m], OpcUa_Good);m++;
		  getAddressSpaceLink()->setReg151_Read (readvals1[m], OpcUa_Good);m++;
		  getAddressSpaceLink()->setReg152_Read (readvals1[m], OpcUa_Good);m++;
		  getAddressSpaceLink()->setReg153_Read (readvals1[m], OpcUa_Good);m++;
		  getAddressSpaceLink()->setReg154_Read (readvals1[m], OpcUa_Good);m++;
		  getAddressSpaceLink()->setReg155_Read (readvals1[m], OpcUa_Good);m++;
		  getAddressSpaceLink()->setReg156_Read (readvals1[m], OpcUa_Good);m++;
		  getAddressSpaceLink()->setReg157_Read (readvals1[m], OpcUa_Good);m++;
		  getAddressSpaceLink()->setReg158_Read (readvals1[m], OpcUa_Good);m++;
		  getAddressSpaceLink()->setReg159_Read (readvals1[m], OpcUa_Good);m++;
		  getAddressSpaceLink()->setReg160_Read (readvals1[m], OpcUa_Good);m++;
		  getAddressSpaceLink()->setReg161_Read (readvals1[m], OpcUa_Good);m++;
		  getAddressSpaceLink()->setReg162_Read (readvals1[m], OpcUa_Good);m++;
		  getAddressSpaceLink()->setReg163_Read (readvals1[m], OpcUa_Good);m++;
		  getAddressSpaceLink()->setReg164_Read (readvals1[m], OpcUa_Good);m++;
		  getAddressSpaceLink()->setReg165_Read (readvals1[m], OpcUa_Good);m++;
		  getAddressSpaceLink()->setReg166_Read (readvals1[m], OpcUa_Good);m++;
		  getAddressSpaceLink()->setReg167_Read (readvals1[m], OpcUa_Good);m++;
		  getAddressSpaceLink()->setReg168_Read (readvals1[m], OpcUa_Good);m++;
		  getAddressSpaceLink()->setReg169_Read (readvals1[m], OpcUa_Good);m++;
		  getAddressSpaceLink()->setReg170_Read (readvals1[m], OpcUa_Good);m++;
		  getAddressSpaceLink()->setReg171_Read (readvals1[m], OpcUa_Good);m=0;
	
		  readvals1.clear();

		  //================================================  For reading registers 10-16 to read the analog values  =======================================================//

		  vector <int> reg10 ={};
		  vector <int> reg11 ={};
		  vector <int> reg12 ={};
		  vector <int> reg13 ={};
		  vector <int> reg14 ={};
		  vector <int> reg15 ={};

		  for (int i=0; i<static_cast<int>(ReadOnlyRegs1.size()); i++)
		  {
			  int number = ReadOnlyRegs1[i];
			  cout<<number<<endl;
			  std::ostringstream ostr_regID;
			  ostr_regID<<number;
			  std::string str_regID = ostr_regID.str();  //converting the reg_ID of int format to a string format
			  cout<<"s = " << str_regID <<"\n";

			  strcpy(reg_ID_temp, str_regID.c_str());
			  cout<<"reg_ID_temp = "<<reg_ID_temp<<endl;
			  //strcat(command, space);
			  strcat (command, reg_ID_temp);

			  cout<<"command = "<<command<<endl;  //the final command

			  pipe = popen(command,"r");

			  if (pipe == NULL) perror("ERROR");
			  else
			  {
				  while(!feof(pipe))
				  {
					  if(fgets(readbuf, 100, pipe) == NULL)
						  field_vect.push_back(readbuf);
				  }
			  }
	    
	    vector <string> tokens;
	    
	    stringstream ss(field_vect[0]);
	    
	    string intermediate;
	    
	    while(getline(ss, intermediate, ' '))
	      tokens.push_back(intermediate);
	    
	    string vals_tk;
	    for (int t=0; t<static_cast<int>(tokens.size()); t++)
	    {
	    	if (tokens[t] == "val")
	    		vals_tk=tokens[t+1];
	    }

	    stringstream val_str(vals_tk);
	    long int val =0.;

	    val_str>>val;
	    
	    //Dividing the register value into separate fields:

	    for (int j=0; j<static_cast<int>(ReadOnlyRegsMap.size()); j++)
	      {
	    	if (ReadOnlyRegs1[i] == ReadOnlyRegsMap[j].regId )
	    	{
		    
				field_name_str = ReadOnlyRegsMap[j].name;
				cout<<field_name_str<<endl;

				int field = bitExtracted(val, (ReadOnlyRegsMap[j].bits), ReadOnlyRegsMap[j].offset+1);
				cout<<"a = "<<val<<"\t"<<ReadOnlyRegsMap[j].bits<<"\t"<<ReadOnlyRegsMap[j].offset<<endl;
				//int field = a<<(ReadOnlyRegsMap[j].offset)-1;

				cout<<"field_name: "<<field_name_str<<";\t value= "<< field<<endl;

				//const char* hexa = hexNum_convert(field);
				//cout<<"field ="<<hexa<<endl;

				if (ReadOnlyRegs1[i]==10)
				  reg10.push_back(DAC_convert(field));
				if (ReadOnlyRegs1[i]==11)
				  reg11.push_back(DAC_convert(field));
				if (ReadOnlyRegs1[i]==12)
				  reg12.push_back(DAC_convert(field));
				if (ReadOnlyRegs1[i]==13)
				  reg13.push_back(DAC_convert(field));
				if (ReadOnlyRegs1[i]==14)
				  reg14.push_back(DAC_convert(field));
				if (ReadOnlyRegs1[i]==15)
				  reg15.push_back(DAC_convert(field));
		    
	    	}
	      }
	    
	    
	    
	    //for (int m=0; m<reg10.size(); m++) cout<<reg10[m];
	    command[strlen(command)-(strlen(reg_ID_temp))] = '\0';

	    pclose(pipe);

	    field_vect.clear();
	    tokens.clear();
	  }
	
	/*cout<<"\n The value is: 0x"<<hexNum_convert(val)<<endl;
	  
	  pclose(pipe);
	  
	  string read_details_cmd = "";
	  
	  for (int j=0; j<field_read.size(); j++)
	  { read_details_cmd = read_details_cmd + field_read[j].first + "\t" + field_read[j].second + "\n"; }

	  getAddressSpaceLink()->setRead_Details (read_details_cmd.c_str(),OpcUa_Good);*/
	
	getAddressSpaceLink()->setReg010_Ch0(reg10[m], OpcUa_Good); m++;
	getAddressSpaceLink()->setReg010_Ch1(reg10[m], OpcUa_Good); m++;
	getAddressSpaceLink()->setReg010_Ch2(reg10[m], OpcUa_Good); m++;
	getAddressSpaceLink()->setReg010_Ae(reg10[m], OpcUa_Good); m=0;
	
	getAddressSpaceLink()->setReg011_Ch3(reg11[m], OpcUa_Good); m++;
	getAddressSpaceLink()->setReg011_Ch4(reg11[m], OpcUa_Good); m++;
	getAddressSpaceLink()->setReg011_Ch5(reg11[m], OpcUa_Good); m++;
	getAddressSpaceLink()->setReg011_Ae(reg11[m], OpcUa_Good); m=0;

	getAddressSpaceLink()->setReg012_Ch6(reg12[m], OpcUa_Good); m++;
	getAddressSpaceLink()->setReg012_Ch7(reg12[m], OpcUa_Good); m++;
	getAddressSpaceLink()->setReg012_Ch8(reg12[m], OpcUa_Good); m++;
	getAddressSpaceLink()->setReg012_Ae(reg12[m], OpcUa_Good); m=0;

	getAddressSpaceLink()->setReg013_Ch09(reg13[m], OpcUa_Good); m++;
	getAddressSpaceLink()->setReg013_Ch10(reg13[m], OpcUa_Good); m++;
	getAddressSpaceLink()->setReg013_Ch11(reg13[m], OpcUa_Good); m++;
	getAddressSpaceLink()->setReg013_Ae(reg13[m], OpcUa_Good); m=0;

	getAddressSpaceLink()->setReg014_Ch12(reg14[m], OpcUa_Good); m++;
	getAddressSpaceLink()->setReg014_Ch13(reg14[m], OpcUa_Good); m++;
	getAddressSpaceLink()->setReg014_Ch14(reg14[m], OpcUa_Good); m++;
	getAddressSpaceLink()->setReg014_Ae(reg14[m], OpcUa_Good); m=0;

	getAddressSpaceLink()->setReg015_Ch15(reg15[m], OpcUa_Good); m++;
	getAddressSpaceLink()->setReg015_Ae(reg15[m], OpcUa_Good); m=0;
	
	reg10.clear();
	reg11.clear();
	reg12.clear();
	reg13.clear();
	reg14.clear();
	reg15.clear();

	command[strlen(command)-sizeof(comm_ID)] = '\0';
	//command[strlen(command)-(strlen(function))] = '\0';
	
      }
    
    // ******************************************* for setting ID *************************************************************** //
    if (setID_fuse == 1)
      {
	const char function[] = "setid_fuse";
	strcat (command, space);
	strcat (command,function);
	strcat (command, space);
	strcat (command,commID_temp);
	strcat (command, space);
	//bond_val_temp = channel_temp;
	strcat(command, "0x");
	strcat (command, Fuse_val_str);

	cout<<"command = "<<command<<endl;  //the final command
	
	pipe = popen(command,"w");
	pclose(pipe);
	
	getAddressSpaceLink()->setSetID_Fuse (0, OpcUa_Good);
      }
    
    
    if (setID_bond == 1)
      {
	const char function[] = "setid_bond";
	strcat (command, space);
	strcat (command,function);
	strcat (command, space);
	strcat (command,commID_temp);
	strcat(command, space);
	//bond_val_temp = channel_temp;
	strcat (command, bond_val_temp);
	
	cout<<"command = "<<command<<endl;  //the final command
	
	pipe = popen(command,"w");
	pclose(pipe);
	
	getAddressSpaceLink()->setSetID_bond (0, OpcUa_Good);
      }
    

    //********************************************************** write to the registers ***************************************************************************//

    vector <int> temp = {};
    if (write_cmd == 1)
      {
	const char function[] = "write";
	strcat (command, space);
	strcat (command,function);
	strcat (command, space);
	strcat (command, commID_temp);
	strcat(command, space);
	
	char valueReg[20]; //for the value to be written to the register
      
	temp.push_back(getAddressSpaceLink()->getReg040_Write());
	temp.push_back(getAddressSpaceLink()->getReg041_Write());
	temp.push_back(getAddressSpaceLink()->getReg042_Write());
	temp.push_back(getAddressSpaceLink()->getReg043_Write());
	temp.push_back(getAddressSpaceLink()->getReg044_Write());
	temp.push_back(getAddressSpaceLink()->getReg045_Write());
	temp.push_back(getAddressSpaceLink()->getReg046_Write());
	temp.push_back(getAddressSpaceLink()->getReg047_Write());
	temp.push_back(getAddressSpaceLink()->getReg048_Write());
	temp.push_back(getAddressSpaceLink()->getReg049_Write());
	temp.push_back(getAddressSpaceLink()->getReg050_Write());
	temp.push_back(getAddressSpaceLink()->getReg051_Write());
	temp.push_back(getAddressSpaceLink()->getReg052_Write());
	temp.push_back(getAddressSpaceLink()->getReg053_Write());
	temp.push_back(getAddressSpaceLink()->getReg054_Write());
	temp.push_back(getAddressSpaceLink()->getReg055_Write());
	temp.push_back(getAddressSpaceLink()->getReg056_Write());
	temp.push_back(getAddressSpaceLink()->getReg057_Write());
	temp.push_back(getAddressSpaceLink()->getReg058_Write());
	temp.push_back(getAddressSpaceLink()->getReg060_Write());
	temp.push_back(getAddressSpaceLink()->getReg061_Write());
	temp.push_back(getAddressSpaceLink()->getReg062_Write());
	temp.push_back(getAddressSpaceLink()->getReg063_Write());
	temp.push_back(getAddressSpaceLink()->getReg064_Write());
	temp.push_back(getAddressSpaceLink()->getReg065_Write());
	temp.push_back(getAddressSpaceLink()->getReg070_Write());
	temp.push_back(getAddressSpaceLink()->getReg071_Write());
	temp.push_back(getAddressSpaceLink()->getReg072_Write());
	temp.push_back(getAddressSpaceLink()->getReg073_Write());
	temp.push_back(getAddressSpaceLink()->getReg074_Write());
	temp.push_back(getAddressSpaceLink()->getReg075_Write());
	temp.push_back(getAddressSpaceLink()->getReg076_Write());
	temp.push_back(getAddressSpaceLink()->getReg077_Write());
	temp.push_back(getAddressSpaceLink()->getReg078_Write());
	temp.push_back(getAddressSpaceLink()->getReg079_Write());
	temp.push_back(getAddressSpaceLink()->getReg080_Write());
	temp.push_back(getAddressSpaceLink()->getReg081_Write());
	temp.push_back(getAddressSpaceLink()->getReg082_Write());
	temp.push_back(getAddressSpaceLink()->getReg083_Write());
	temp.push_back(getAddressSpaceLink()->getReg084_Write());
	temp.push_back(getAddressSpaceLink()->getReg085_Write());
	temp.push_back(getAddressSpaceLink()->getReg086_Write());
	temp.push_back(getAddressSpaceLink()->getReg087_Write());
	temp.push_back(getAddressSpaceLink()->getReg090_Write());
	temp.push_back(getAddressSpaceLink()->getReg091_Write());
	temp.push_back(getAddressSpaceLink()->getReg092_Write());
	temp.push_back(getAddressSpaceLink()->getReg093_Write());
	temp.push_back(getAddressSpaceLink()->getReg094_Write());
	temp.push_back(getAddressSpaceLink()->getReg095_Write());
	temp.push_back(getAddressSpaceLink()->getReg096_Write());
	temp.push_back(getAddressSpaceLink()->getReg100_Write());
	temp.push_back(getAddressSpaceLink()->getReg101_Write());
	temp.push_back(getAddressSpaceLink()->getReg102_Write());
	temp.push_back(getAddressSpaceLink()->getReg103_Write());
	temp.push_back(getAddressSpaceLink()->getReg104_Write());
	temp.push_back(getAddressSpaceLink()->getReg105_Write());
	temp.push_back(getAddressSpaceLink()->getReg106_Write());
	temp.push_back(getAddressSpaceLink()->getReg107_Write());
	temp.push_back(getAddressSpaceLink()->getReg108_Write());
	temp.push_back(getAddressSpaceLink()->getReg109_Write());
	temp.push_back(getAddressSpaceLink()->getReg110_Write());
	temp.push_back(getAddressSpaceLink()->getReg111_Write());
	temp.push_back(getAddressSpaceLink()->getReg112_Write());
	temp.push_back(getAddressSpaceLink()->getReg113_Write());
	temp.push_back(getAddressSpaceLink()->getReg114_Write());
	temp.push_back(getAddressSpaceLink()->getReg115_Write());
	temp.push_back(getAddressSpaceLink()->getReg116_Write());
	temp.push_back(getAddressSpaceLink()->getReg117_Write());
	temp.push_back(getAddressSpaceLink()->getReg118_Write());
	temp.push_back(getAddressSpaceLink()->getReg119_Write());
	temp.push_back(getAddressSpaceLink()->getReg120_Write());
	temp.push_back(getAddressSpaceLink()->getReg121_Write());
	temp.push_back(getAddressSpaceLink()->getReg122_Write());
	temp.push_back(getAddressSpaceLink()->getReg123_Write());
	temp.push_back(getAddressSpaceLink()->getReg124_Write());
	temp.push_back(getAddressSpaceLink()->getReg125_Write());
	temp.push_back(getAddressSpaceLink()->getReg126_Write());
	temp.push_back(getAddressSpaceLink()->getReg127_Write());
	temp.push_back(getAddressSpaceLink()->getReg128_Write());
	temp.push_back(getAddressSpaceLink()->getReg129_Write());
	temp.push_back(getAddressSpaceLink()->getReg130_Write());
	temp.push_back(getAddressSpaceLink()->getReg131_Write());
	temp.push_back(getAddressSpaceLink()->getReg132_Write());
	temp.push_back(getAddressSpaceLink()->getReg133_Write());
	temp.push_back(getAddressSpaceLink()->getReg134_Write());
	temp.push_back(getAddressSpaceLink()->getReg135_Write());
	temp.push_back(getAddressSpaceLink()->getReg136_Write());
	temp.push_back(getAddressSpaceLink()->getReg137_Write());
	temp.push_back(getAddressSpaceLink()->getReg138_Write());
	temp.push_back(getAddressSpaceLink()->getReg139_Write());
	temp.push_back(getAddressSpaceLink()->getReg140_Write());
	temp.push_back(getAddressSpaceLink()->getReg141_Write());
	temp.push_back(getAddressSpaceLink()->getReg142_Write());
	temp.push_back(getAddressSpaceLink()->getReg143_Write());
	temp.push_back(getAddressSpaceLink()->getReg144_Write());
	temp.push_back(getAddressSpaceLink()->getReg145_Write());
	temp.push_back(getAddressSpaceLink()->getReg146_Write());
	temp.push_back(getAddressSpaceLink()->getReg147_Write());
	temp.push_back(getAddressSpaceLink()->getReg148_Write());
	temp.push_back(getAddressSpaceLink()->getReg149_Write());
	temp.push_back(getAddressSpaceLink()->getReg150_Write());
	temp.push_back(getAddressSpaceLink()->getReg151_Write());
	temp.push_back(getAddressSpaceLink()->getReg152_Write());
	temp.push_back(getAddressSpaceLink()->getReg153_Write());
	temp.push_back(getAddressSpaceLink()->getReg154_Write());
	temp.push_back(getAddressSpaceLink()->getReg155_Write());
	temp.push_back(getAddressSpaceLink()->getReg156_Write());
	temp.push_back(getAddressSpaceLink()->getReg157_Write());
	temp.push_back(getAddressSpaceLink()->getReg158_Write());
	temp.push_back(getAddressSpaceLink()->getReg159_Write());
	temp.push_back(getAddressSpaceLink()->getReg160_Write());
	temp.push_back(getAddressSpaceLink()->getReg161_Write());
	temp.push_back(getAddressSpaceLink()->getReg162_Write());
	temp.push_back(getAddressSpaceLink()->getReg163_Write());
	temp.push_back(getAddressSpaceLink()->getReg164_Write());
	temp.push_back(getAddressSpaceLink()->getReg165_Write());
	temp.push_back(getAddressSpaceLink()->getReg166_Write());
	temp.push_back(getAddressSpaceLink()->getReg167_Write());
	temp.push_back(getAddressSpaceLink()->getReg168_Write());
	temp.push_back(getAddressSpaceLink()->getReg169_Write());
	temp.push_back(getAddressSpaceLink()->getReg170_Write());
	temp.push_back(getAddressSpaceLink()->getReg171_Write());
	
	
	for(int i=0; i<static_cast<int>(ReadWriteRegs.size()); i++)
	  {
	    strcpy(valueReg, hexNum_convert(temp[i]));
	    strcpy(reg_ID_temp, intChar_convert(ReadWriteRegs[i]));
	    strcat (command, reg_ID_temp);
	    strcat(command, space);
	    strcat(command, "0x");
	    strcat (command, valueReg);
	    cout<<"command = "<<command<<endl;  //the final command
	    
	    pipe = popen(command,"w");
	    pclose(pipe);
	  
	    command[strlen(command)-(strlen(valueReg)+3)] = '\0';
	    command[strlen(command)-(strlen(reg_ID_temp))] = '\0';
	    memset(reg_ID_temp, 0, sizeof(reg_ID_temp));
	    memset(valueReg, 0, sizeof(valueReg));
	  }
	
	getAddressSpaceLink()->setWrite (0, OpcUa_Good);
	temp.clear();
      }
    
    
    
  }
  
  
  
}



